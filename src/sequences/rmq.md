---
tags:
  - AI Translated
e_maxx_link: rmq
---

# پرس و جوی کمینه در بازه (Range Minimum Query)

یک آرایه $A[1..N]$ به شما داده شده است.
شما باید به پرس و جوهای ورودی به شکل $(L, R)$ پاسخ دهید که درخواست یافتن عنصر کمینه در آرایه $A$ بین موقعیت‌های $L$ و $R$ (شامل خودشان) را دارند.

مسئله RMQ ممکن است مستقیماً در مسائل ظاهر شود یا در وظایف دیگری مانند مسئله [پایین‌ترین جد مشترک (Lowest Common Ancestor)](../graph/lca.md) کاربرد داشته باشد.

## راه‌حل

رویکردها و ساختمان داده‌های ممکن زیادی برای حل مسئله RMQ وجود دارد.

مواردی که در این سایت توضیح داده شده‌اند در زیر لیست شده‌اند.

ابتدا رویکردهایی که امکان تغییر در آرایه بین پاسخ به پرس و جوها را فراهم می‌کنند:

- [Sqrt-decomposition](../data_structures/sqrt_decomposition.md) - به هر پرس و جو در $O(\sqrt{N})$ پاسخ می‌دهد، پیش‌پردازش در $O(N)$ انجام می‌شود.
  مزایا: یک ساختمان داده بسیار ساده. معایب: پیچیدگی زمانی بدتر.
- [درخت بازه‌ها (Segment tree)](../data_structures/segment_tree.md) - به هر پرس و جو در $O(\log N)$ پاسخ می‌دهد، پیش‌پردازش در $O(N)$ انجام می‌شود.
  مزایا: پیچیدگی زمانی خوب. معایب: حجم کد بیشتر در مقایسه با سایر ساختمان داده‌ها.
- [درخت فنویک (Fenwick tree)](../data_structures/fenwick.md) - به هر پرس و جو در $O(\log N)$ پاسخ می‌دهد، پیش‌پردازش در $O(N \log N)$ انجام می‌شود.
  مزایا: کوتاه‌ترین کد، پیچیدگی زمانی خوب. معایب: درخت فنویک فقط برای پرس و جوهایی با $L = 1$ قابل استفاده است، بنابراین برای بسیاری از مسائل کاربرد ندارد.

و در اینجا رویکردهایی هستند که فقط روی آرایه‌های ایستا کار می‌کنند، یعنی امکان تغییر یک مقدار در آرایه بدون محاسبه مجدد کل ساختمان داده وجود ندارد.

- [جدول پراکنده (Sparse Table)](../data_structures/sparse-table.md) - به هر پرس و جو در $O(1)$ پاسخ می‌دهد، پیش‌پردازش در $O(N \log N)$ انجام می‌شود.
  مزایا: ساختمان داده ساده، پیچیدگی زمانی عالی.
- [Sqrt Tree](../data_structures/sqrt-tree.md) - به پرس و جوها در $O(1)$ پاسخ می‌دهد، پیش‌پردازش در $O(N \log \log N)$ انجام می‌شود. مزایا: سریع. معایب: پیاده‌سازی آن پیچیده است.
- [Disjoint Set Union / ترفند آرپا (Arpa's Trick)](../data_structures/disjoint_set_union.md#arpa) - به پرس و جوها در $O(1)$ پاسخ می‌دهد، پیش‌پردازش در $O(n)$. مزایا: کوتاه، سریع. معایب: تنها در صورتی کار می‌کند که تمام پرس و جوها از قبل مشخص باشند، یعنی فقط از پردازش آفلاین پرس و جوها پشتیبانی می‌کند.
- [درخت دکارتی (Cartesian Tree)](../graph/rmq_linear.md) و [الگوریتم Farach-Colton and Bender](../graph/lca_farachcoltonbender.md) - به پرس و جوها در $O(1)$ پاسخ می‌دهد، پیش‌پردازش در $O(n)$. مزایا: پیچیدگی بهینه. معایب: حجم کد زیاد.

نکته: پیش‌پردازش (Preprocessing) به پردازش اولیه‌ی آرایه داده شده از طریق ساخت ساختمان داده مربوط به آن گفته می‌شود.

## مسائل تمرینی
- [SPOJ: Range Minimum Query](http://www.spoj.com/problems/RMQSQ/)
- [CODECHEF: Chef And Array](https://www.codechef.com/problems/FRMQ)
- [Codeforces: Array Partition](https://codeforces.com/contest/1454/problem/F)