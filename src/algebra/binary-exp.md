---
tags:
  - AI Translated
e_maxx_link: binary_pow
---

# توان‌رسانی دودویی (Binary Exponentiation)

رفیق، «توان‌رسانی دودویی» (که بهش «توان‌رسانی با مربع‌سازی» یا Exponentiation by Squaring هم میگن) یه تکنیک خیلی باحاله که بهت اجازه میده $a^n$ رو فقط با $O(\log n)$ تا ضرب حساب کنی (به جای $O(n)$ تا ضرب توی روش ساده و معمولی).

این روش کلی کاربرد خفن دیگه هم توی مسائلی داره که شاید در نگاه اول ربطی به حساب و کتاب نداشته باشن. کل ماجرا اینه که می‌تونی از این تکنیک برای هر عملیاتی که خاصیت **شرکت‌پذیری (associativity)** داشته باشه استفاده کنی:

$$(X \cdot Y) \cdot Z = X \cdot (Y \cdot Z)$$

واضح‌ترین کاربردهاش توی ضرب پیمانه‌ای، ضرب ماتریس‌ها و یه سری مسائل دیگه است که جلوتر با هم می‌بینیم.

## الگوریتم چطوری کار می‌کنه؟

خب، ساده‌ترین راه برای به توان رسوندن $a$ به توان $n$ اینه که $a$ رو $n-1$ بار توی خودش ضرب کنی:
$a^{n} = a \cdot a \cdot \ldots \cdot a$. ولی خب این روش برای $a$ یا $n$ های بزرگ اصلاً به درد نمی‌خوره و خیلی کنده.

یادت باشه که: $a^{b+c} = a^b \cdot a^c$ و $a^{2b} = a^b \cdot a^b = (a^b)^2$.

ایده اصلی توان‌رسانی دودویی اینه که بیایم توان، یعنی $n$، رو به صورت باینری (دودویی) ببینیم و مسئله رو بشکنیم.

بذار $n$ رو تو مبنای ۲ بنویسیم، مثلاً برای $13$:

$$3^{13} = 3^{1101_2} = 3^8 \cdot 3^4 \cdot 3^1$$

از اونجایی که عدد $n$ توی مبنای ۲ دقیقاً $\lfloor \log_2 n \rfloor + 1$ تا رقم داره، اگه ما توان‌های $a^1, a^2, a^4, a^8, \dots, a^{2^{\lfloor \log n \rfloor}}$ رو داشته باشیم، فقط به $O(\log n)$ تا ضرب نیاز داریم تا جواب نهایی رو بسازیم.

خب حالا فقط باید یه راه سریع برای حساب کردن اینا پیدا کنیم.
خوشبختانه این کار خیلی راحته، چون هر عضو این دنباله، مربع عضو قبلیشه.

$$\begin{align}
3^1 &= 3 \\
3^2 &= \left(3^1\right)^2 = 3^2 = 9 \\
3^4 &= \left(3^2\right)^2 = 9^2 = 81 \\
3^8 &= \left(3^4\right)^2 = 81^2 = 6561
\end{align}$$

پس برای اینکه جواب نهایی $3^{13}$ رو به دست بیاریم، کافیه سه تا از اینا رو توی هم ضرب کنیم (از $3^2$ صرف‌نظر می‌کنیم چون بیت متناظرش در نمایش باینری $13$ یعنی $1101_2$ صفر است).
$3^{13} = 6561 \cdot 81 \cdot 3 = 1594323$

پیچیدگی نهایی این الگوریتم $O(\log n)$ هست: ما باید $\log n$ تا توان از $a$ رو حساب کنیم و بعدش هم حداکثر $\log n$ تا ضرب انجام بدیم تا به جواب نهایی برسیم.

اگه بخوایم همین ایده رو به صورت بازگشتی (recursive) بنویسیم، یه همچین چیزی میشه:

$$a^n = \begin{cases}
1 &\text{اگر } n == 0 \\
\left(a^{\frac{n}{2}}\right)^2 &\text{اگر } n > 0 \text{ و } n \text{ زوج باشه}\\
\left(a^{\frac{n - 1}{2}}\right)^2 \cdot a &\text{اگر } n > 0 \text{ و } n \text{ فرد باشه}\\
\end{cases}$$

## پیاده‌سازی

اول بریم سراغ پیاده‌سازی بازگشتی، که دقیقاً ترجمه‌ی همون فرمول بالاست:

```cpp
long long binpow(long long a, long long b) {
    if (b == 0)
        return 1;
    long long res = binpow(a, b / 2);
    if (b % 2)
        return res * res * a;
    else
        return res * res;
}
```

حالا بریم سراغ روش دوم که همین کار رو بدون بازگشت (iterative) انجام میده.
این روش توی یه حلقه، همه توان‌ها رو حساب می‌کنه و اونایی که بیت متناظرشون توی $n$ یک هست رو توی نتیجه ضرب می‌کنه.
با اینکه پیچیدگی زمانی هر دو روش یکیه، این روش دوم توی عمل سریع‌تره، چون دیگه سربار (overhead) فراخوانی‌های بازگشتی رو نداریم.

```cpp
long long binpow(long long a, long long b) {
    long long res = 1;
    while (b > 0) {
        if (b & 1)
            res = res * a;
        a = a * a;
        b >>= 1;
    }
    return res;
}
```

## کاربردها

### محاسبه بهینه توان‌های بزرگ به پیمانه یک عدد

**مسئله:**
می‌خوایم $x^n \bmod m$ رو حساب کنیم.
این یه عملیات خیلی رایجه. مثلاً برای محاسبه [وارون ضربی پیمانه‌ای](module-inverse.md) ازش استفاده میشه.

**راه حل:**
خبر خوب اینه که عملگر مود (پیمانه) با ضرب خیلی خوب کنار میاد ($a \cdot b \equiv (a \bmod m) \cdot (b \bmod m) \pmod m$). پس می‌تونیم دقیقاً از همون کد بالا استفاده کنیم و فقط هر ضرب رو با یه ضرب پیمانه‌ای عوض کنیم:

```cpp
long long binpow(long long a, long long b, long long m) {
    a %= m;
    long long res = 1;
    while (b > 0) {
        if (b & 1)
            res = res * a % m;
        a = a * a % m;
        b >>= 1;
    }
    return res;
}
```

**نکته:**
یه نکته باحال: اگه $b$ خیلی بزرگ باشه (مثلاً خیلی بزرگ‌تر از $m$)، می‌تونی این الگوریتم رو از این هم سریع‌تر کنی.
اگه $m$ یه عدد اول باشه، $x^n \equiv x^{n \bmod (m-1)} \pmod{m}$ برقراره و اگه $m$ مرکب باشه $x^n \equiv x^{n \bmod{\phi(m)}} \pmod{m}$ برقراره.
این قضیه مستقیم از قضیه کوچک فرما و قضیه اویلر نتیجه میشه. برای جزئیات بیشتر یه نگاهی به مقاله [وارون‌های پیمانه‌ای](module-inverse.md#fermat-euler) بنداز.

### محاسبه بهینه اعداد فیبوناچی

**مسئله:** می‌خوایم $n$-امین عدد فیبوناچی ($F_n$) رو پیدا کنیم.

**راه حل:** برای جزئیات کامل‌تر، حتماً مقاله [اعداد فیبوناچی](fibonacci-numbers.md) رو ببین، ولی اینجا یه خلاصه‌ای از الگوریتم رو با هم مرور می‌کنیم.
برای حساب کردن عدد فیبوناچی بعدی، فقط به دو تای قبلی نیاز داریم، چون $F_n = F_{n-1} + F_{n-2}$.
ایده اینه که می‌تونیم یه ماتریس $2 \times 2$ بسازیم که این تبدیل رو توصیف کنه:
یعنی انتقال از زوج $(F_i, F_{i+1})$ به زوج $(F_{i+1}, F_{i+2})$.
مثلاً، اگه این تبدیل رو روی زوج $(F_0, F_1)$ اعمال کنیم، بهمون $(F_1, F_2)$ رو میده.
بنابراین، می‌تونیم این ماتریس تبدیل رو به توان $n$ برسونیم تا $F_n$ رو با پیچیدگی زمانی $O(\log n)$ پیدا کنیم.

### اعمال یک جایگشت به تعداد $k$ بار { data-toc-label='اعمال یک جایگشت به تعداد <script type="math/tex">k</script> بار' }

**مسئله:** فرض کن یه دنباله به طول $n$ داری و می‌خوای یه جایگشت (permutation) مشخص رو $k$ بار روش اعمال کنی.

**راه حل:** خیلی ساده‌ست! خودِ جایگشت رو یه جور عملیات در نظر بگیر و با استفاده از توان‌رسانی دودویی، این عملیات رو به توان $k$ برسون و بعد نتیجه رو روی دنباله اعمال کن. این کار پیچیدگی زمانی $O(n \log k)$ بهت میده.

```cpp
vector<int> applyPermutation(vector<int> sequence, vector<int> permutation) {
    vector<int> newSequence(sequence.size());
    for(int i = 0; i < sequence.size(); i++) {
        newSequence[i] = sequence[permutation[i]];
    }
    return newSequence;
}

vector<int> permute(vector<int> sequence, vector<int> permutation, long long k) {
    while (k > 0) {
        if (k & 1) {
            sequence = applyPermutation(sequence, permutation);
        }
        permutation = applyPermutation(permutation, permutation);
        k >>= 1;
    }
    return sequence;
}
```

**نکته:** این مسئله رو میشه بهینه‌تر و توی زمان خطی هم حل کرد. چطوری؟ گراف جایگشت رو بساز و هر دور (cycle) رو جداگانه بررسی کن. بعد می‌تونی $k$ رو به پیمانه طول اون دور حساب کنی و موقعیت نهایی هر عدد توی اون دور رو پیدا کنی.

### اعمال سریع مجموعه‌ای از عملیات هندسی بر روی مجموعه‌ای از نقاط

**مسئله:** این یکی خیلی جالبه! فرض کن $n$ تا نقطه $p_i$ داری و می‌خوای $m$ تا تبدیل هندسی رو روی همه‌شون اعمال کنی. هر تبدیل می‌تونه انتقال (translation)، تغییر مقیاس (scaling) یا دوران (rotation) حول یه محور مشخص با یه زاویه مشخص باشه. یه عملیات "حلقه" (loop) هم داریم که یه لیست از تبدیل‌ها رو $k$ بار تکرار می‌کنه (این حلقه‌ها می‌تونن تودرتو باشن). تو باید همه این تبدیل‌ها رو سریع‌تر از $O(n \cdot length)$ انجام بدی، که `length` تعداد کل تبدیل‌ها بعد از باز کردن حلقه‌هاست.

**راه حل:** بیا ببینیم این تبدیل‌ها چطوری مختصات رو تغییر میدن:

*   **انتقال:** یه عدد ثابت به هر کدوم از مختصات اضافه می‌کنه.
*   **تغییر مقیاس:** هر کدوم از مختصات رو توی یه عدد ثابت ضرب می‌کنه.
*   **دوران:** این یکم پیچیده‌تره (اینجا وارد جزئیاتش نمیشیم)، ولی هر مختصات جدید باز هم یه ترکیب خطی از مختصات قدیمیه.

همونطور که می‌بینی، هر کدوم از این تبدیل‌ها رو میشه به صورت یه عملیات خطی روی مختصات نشون داد. پس، یه تبدیل رو میشه به شکل یه ماتریس $4 \times 4$ نوشت:

$$\begin{pmatrix}
a_{11} & a_ {12} & a_ {13} & a_ {14} \\
a_{21} & a_ {22} & a_ {23} & a_ {24} \\
a_{31} & a_ {32} & a_ {33} & a_ {34} \\
a_{41} & a_ {42} & a_ {43} & a_ {44}
\end{pmatrix}$$

که اگه توی یه بردار با مختصات قدیمی و یه عدد ۱ ضرب بشه، یه بردار جدید با مختصات جدید و یه عدد ۱ بهمون میده:

$$\begin{pmatrix} x & y & z & 1 \end{pmatrix} \cdot
\begin{pmatrix}
a_{11} & a_ {12} & a_ {13} & a_ {14} \\
a_{21} & a_ {22} & a_ {23} & a_ {24} \\
a_{31} & a_ {32} & a_ {33} & a_ {34} \\
a_{41} & a_ {42} & a_ {43} & a_ {44}
\end{pmatrix}
 = \begin{pmatrix} x' & y' & z' & 1 \end{pmatrix}$$

(شاید بپرسی این مختصات چهارم الکی از کجا اومد؟ این همون جادوی [مختصات همگن (Homogeneous coordinates)](https://en.wikipedia.org/wiki/Homogeneous_coordinates) هست که توی گرافیک کامپیوتری خیلی کاربرد داره. بدون اون، نمی‌تونستیم تبدیل‌های آفین (affine) مثل انتقال رو به صورت یه ضرب ماتریسی ساده پیاده‌سازی کنیم، چون انتقال نیاز داره که یه عدد ثابت به مختصات *اضافه* بشه. با این کار، یه تبدیل آفین توی بعد بالاتر به یه تبدیل خطی تبدیل میشه!)

اینم چندتا مثال از ماتریس‌های تبدیل:

*   **انتقال:** مختصات $x$ رو ۵ واحد، $y$ رو ۷ واحد و $z$ رو ۹ واحد جابجا می‌کنه.

$$\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
5 & 7 & 9 & 1
\end{pmatrix}$$

*   **تغییر مقیاس:** مختصات $x$ رو ۱۰ برابر و دو تای دیگه رو ۵ برابر می‌کنه.

$$\begin{pmatrix}
10 & 0 & 0 & 0 \\
0 & 5 & 0 & 0 \\
0 & 0 & 5 & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}$$

*   **دوران:** دوران به اندازه $\theta$ درجه حول محور $x$ طبق قانون دست راست (پادساعتگرد).

$$\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & \cos \theta & -\sin \theta & 0 \\
0 & \sin \theta & \cos \theta & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}$$

حالا که هر تبدیل رو به شکل یه ماتریس درآوردیم، یه دنباله از تبدیل‌ها میشه حاصل‌ضرب ماتریس‌هاشون، و یه "حلقه" با $k$ بار تکرار میشه همون ماتریس به توان $k$ (که با توان‌رسانی دودویی توی $O(\log{k})$ حساب میشه). اینطوری، اول ماتریس نهایی که همه تبدیل‌ها رو نشون میده توی $O(m \log{k})$ حساب می‌کنیم و بعدش توی $O(n)$ روی همه $n$ تا نقطه اعمالش می‌کنیم. پیچیدگی کل میشه $O(n + m \log{k})$.

### تعداد مسیرهای به طول $k$ در یک گراف { data-toc-label='تعداد مسیرهای به طول <script type="math/tex">k</script> در یک گراف' }

**مسئله:** فرض کن یه گراف جهت‌دار بدون وزن با $n$ تا رأس داری. حالا می‌خوای تعداد مسیرهایی که دقیقاً $k$ تا یال دارن رو از هر رأس $u$ به هر رأس $v$ پیدا کنی.

**راه حل:** این مسئله با جزئیات بیشتر توی [یه مقاله جدا](../graph/fixed_length_paths.md) بررسی شده. الگوریتم اینه که ماتریس مجاورت (Adjacency Matrix) گراف یعنی $M$ رو به توان $k$ برسونی (ماتریسی که توش $m_{ij} = 1$ اگه یالی از $i$ به $j$ باشه وگرنه $0$ هست). حالا $m_{ij}$ میشه تعداد مسیرهای به طول $k$ از $i$ به $j$. پیچیدگی زمانی این راه حل $O(n^3 \log k)$ هست.

**نکته:** توی همون مقاله، یه مدل دیگه از این مسئله هم بررسی شده: وقتی که یال‌ها وزن‌دار هستن و باید مسیری با کمترین وزن پیدا کنی که دقیقاً $k$ تا یال داشته باشه. همونطور که اونجا نشون داده شده، این مسئله هم با به توان رسوندن ماتریس مجاورت حل میشه. ماتریس شامل وزن یال از $i$ به $j$ یا $\infty$ اگه یالی نباشه، خواهد بود.
فقط به جای عملیات ضرب ماتریسی معمولی، باید از یه عملیات تغییر یافته استفاده کنی:
به جای ضرب، دو تا مقدار با هم جمع میشن و به جای جمع‌بندی، مینیمم گرفته میشه.
یعنی: $result_{ij} = \min\limits_{1\ \leq\ k\ \leq\ n}(a_{ik} + b_{kj})$.

### نوعی از توان‌رسانی دودویی: ضرب دو عدد به پیمانه $m$ { data-toc-label='نوعی از توان‌رسانی دودویی: ضرب دو عدد به پیمانه <script type="math/tex">m</script>' }

**مسئله:** این یه کاربرد یکم متفاوته. فرض کن می‌خوای دو تا عدد $a$ و $b$ رو به پیمانه $m$ ضرب کنی. مشکل اینجاست که $a$ و $b$ توی یه متغیر ۶۴ بیتی جا میشن، ولی حاصل‌ضربشون $a \cdot b$ ممکنه سرریز کنه (overflow) و توی متغیر ۶۴ بیتی جا نشه. ایده اینه که $a \cdot b \pmod m$ رو بدون استفاده از کتابخونه‌های اعداد بزرگ (bignum) حساب کنیم.

**راه حل:** ما خیلی راحت از همون الگوریتم توان‌رسانی دودویی که بالا گفتیم استفاده می‌کنیم، فقط به جای ضرب، از جمع استفاده می‌کنیم. به عبارت دیگه، ما ضرب دو تا عدد رو به $O(\log b)$ تا عملیات جمع و ضرب در دو (که اونم خودش یه جور جمعه) "باز" کردیم.

$$a \cdot b = \begin{cases}
0 &\text{اگر }b = 0 \\
2 \cdot a \cdot \frac{b}{2} &\text{اگر }b > 0 \text{ و }b \text{ زوج باشه} \\
2 \cdot a \cdot \frac{b-1}{2} + a &\text{اگر }b > 0 \text{ و }b \text{ فرد باشه}
\end{cases}$$

**نکته:** می‌تونی این مسئله رو با یه روش دیگه با استفاده از اعداد ممیز شناور (floating-point) هم حل کنی. اول عبارت $\frac{a \cdot b}{m}$ رو با استفاده از اعداد ممیز شناور حساب کن و نتیجه رو به یه عدد صحیح بدون علامت $q$ تبدیل کن. بعد $q \cdot m$ رو با استفاده از حساب اعداد صحیح بدون علامت از $a \cdot b$ کم کن و نتیجه رو به پیمانه $m$ بگیر تا به جواب برسی. این راه حل شاید یکم غیرقابل اعتماد به نظر بیاد، ولی خیلی سریعه و پیاده‌سازیش هم خیلی راحته. برای اطلاعات بیشتر [اینجا](https://cs.stackexchange.com/questions/77016/modular-multiplication) رو ببین.

## مسائل تمرینی

اینم چندتا مسئله برای تمرین بیشتر تا دستت راه بیفته:

* [UVa 1230 - MODEX](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=3671)
* [UVa 374 - Big Mod](http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=310)
* [UVa 11029 - Leading and Trailing](https://uva.onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1970)
* [Codeforces - Parking Lot](http://codeforces.com/problemset/problem/630/I)
* [leetcode - Count good numbers](https://leetcode.com/problems/count-good-numbers/)
* [Codechef - Chef and Riffles](https://www.codechef.com/JAN221B/problems/RIFFLES)
* [Codeforces - Decoding Genome](https://codeforces.com/contest/222/problem/E)
* [Codeforces - Neural Network Country](https://codeforces.com/contest/852/problem/B)
* [Codeforces - Magic Gems](https://codeforces.com/problemset/problem/1117/D)
* [SPOJ - The last digit](http://www.spoj.com/problems/LASTDIG/)
* [SPOJ - Locker](http://www.spoj.com/problems/LOCKER/)
* [LA - 3722 Jewel-eating Monsters](https://vjudge.net/problem/UVALive-3722)
* [SPOJ - Just add it](http://www.spoj.com/problems/ZSUM/)
* [Codeforces - Stairs and Lines](https://codeforces.com/contest/498/problem/E)