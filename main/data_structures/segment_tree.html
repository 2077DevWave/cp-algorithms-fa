
<!doctype html>
<html lang="fa" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="The goal of this project is to translate the wonderful resource http://e-maxx.ru/algo which provides descriptions of many algorithms and data structures especially popular in field of competitive programming. Moreover we want to improve the collected knowledge by extending the articles and adding new articles to the collection.">
      
      
      
        <link rel="canonical" href="https://cp-algorithms.com/data_structures/segment_tree.html">
      
      
        <link rel="prev" href="sqrt_decomposition.html">
      
      
        <link rel="next" href="treap.html">
      
      
        <link rel="alternate" type="application/rss+xml" title="خوراک آراس‌اس" href="../feed_rss_created.xml">
        <link rel="alternate" type="application/rss+xml" title="خوراک آراساس محتویات به‌روز شده" href="../feed_rss_updated.xml">
      
      <link rel="icon" href="../favicon.ico">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.15">
    
    
      
        <title>درخت بازه‌ها - Algorithms for Competitive Programming</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.342714a4.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../stylesheets/rtl.css">
    
      <link rel="stylesheet" href="../stylesheets/extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      
  


  
  

<script id="__analytics">function __md_analytics(){function e(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],e("js",new Date),e("config","G-7FLS2HCYHH"),document.addEventListener("DOMContentLoaded",(function(){document.forms.search&&document.forms.search.query.addEventListener("blur",(function(){this.value&&e("event","search",{search_term:this.value})}));document$.subscribe((function(){var t=document.forms.feedback;if(void 0!==t)for(var a of t.querySelectorAll("[type=submit]"))a.addEventListener("click",(function(a){a.preventDefault();var n=document.location.pathname,d=this.getAttribute("data-md-value");e("event","feedback",{page:n,data:d}),t.firstElementChild.disabled=!0;var r=t.querySelector(".md-feedback__note [data-md-value='"+d+"']");r&&(r.hidden=!1)})),t.hidden=!1})),location$.subscribe((function(t){e("config","G-7FLS2HCYHH",{page_path:t.pathname})}))}));var t=document.createElement("script");t.async=!0,t.src="https://www.googletagmanager.com/gtag/js?id=G-7FLS2HCYHH",document.getElementById("__analytics").insertAdjacentElement("afterEnd",t)}</script>
  
    <script>"undefined"!=typeof __md_analytics&&__md_analytics()</script>
  

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="rtl" data-md-color-scheme="cpalgo" data-md-color-primary="deep-purple" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#segment-tree" class="md-skip">
          پرش به محتویات
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      <!-- overwrite:
- scroll to top when clicking title
- go to main page when clicking the site title
-->


<header class="md-header" data-md-component="header">
  <script>
    function scrollToTop() {
      document.body.scrollTop = 0; // For Safari
      document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
    }
  </script>
  <nav class="md-header__inner md-grid" aria-label="header.title">
    <a href=".." title="Algorithms for Competitive Programming" class="md-header__button md-logo" aria-label="Algorithms for Competitive Programming" data-md-component="logo">
      
  <img src="../favicon.ico" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            <a href=".." title="Algorithms for Competitive Programming" aria-label="Algorithms for Competitive Programming" data-md-component="logo">
              Algorithms for Competitive Programming
            </a>
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            <a href="#" onclick="scrollToTop()">
              
                درخت بازه‌ها
              
            </a>
          </span>
        </div>
      </div>
    </div>
    
      <form class="md-header__option" data-md-component="palette">
        
          
          
          <input class="md-option" data-md-color-media="" data-md-color-scheme="cpalgo" data-md-color-primary="deep-purple" data-md-color-accent=""  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
          
            <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
            </label>
          
        
          
          
          <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="" data-md-color-accent=""  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
          
            <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
            </label>
          
        
      </form>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="جستجو" placeholder="جستجو" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="جستجو">
        
        <button type="reset" class="md-search__icon md-icon" title="بازنشانی" aria-label="بازنشانی" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            راه‌اندازی جستجو
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/cp-algorithms/cp-algorithms" title="رفتن به مخزن" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    cp-algorithms/cp-algorithms
  </div>
</a>
      </div>
    
      <div class="rss icon">
      <a href="https://cp-algorithms.com/feed_rss_created.xml" title="RSS" class="md-content__button md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M0 64c0-17.7 14.3-32 32-32 229.8 0 416 186.2 416 416 0 17.7-14.3 32-32 32s-32-14.3-32-32C384 253.6 226.4 96 32 96 14.3 96 0 81.7 0 64m0 352a64 64 0 1 1 128 0 64 64 0 1 1-128 0m32-256c159.1 0 288 128.9 288 288 0 17.7-14.3 32-32 32s-32-14.3-32-32c0-123.7-100.3-224-224-224-17.7 0-32-14.3-32-32s14.3-32 32-32"/></svg>
      </a>
      </div>

    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



  

<nav class="md-nav md-nav--primary md-nav--integrated" aria-label="هدایت" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Algorithms for Competitive Programming" class="md-nav__button md-logo" aria-label="Algorithms for Competitive Programming" data-md-component="logo">
      
  <img src="../favicon.ico" alt="logo">

    </a>
    Algorithms for Competitive Programming
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/cp-algorithms/cp-algorithms" title="رفتن به مخزن" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    cp-algorithms/cp-algorithms
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_1" >
        
          
          <label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    خانه
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            خانه
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../index.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    صفحه اصلی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../navigation.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ناوبری
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../tags.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    فهرست برچسب‌ها
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../contrib.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    چگونه مشارکت کنیم
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../code_of_conduct.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    آیین‌نامه رفتاری
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../preview.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    پیش‌نمایش
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    جبر
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            جبر
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1" >
        
          
          <label class="md-nav__link" for="__nav_2_1" id="__nav_2_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    مبانی
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1">
            <span class="md-nav__icon md-icon"></span>
            مبانی
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/binary-exp.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    توان‌رسانی دودویی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/euclid-algorithm.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    الگوریتم اقلیدس برای محاسبه بزرگترین مقسوم‌علیه مشترک
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/extended-euclid-algorithm.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    الگوریتم اقلیدس تعمیم‌یافته
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/linear-diophantine-equation.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    معادلات سیاله خطی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/fibonacci-numbers.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    اعداد فیبوناچی
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    اعداد اول
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            اعداد اول
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/sieve-of-eratosthenes.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    غربال اراتستن
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/prime-sieve-linear.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    غربال خطی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/primality_tests.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    آزمون‌های اول بودن
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/factorization.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تجزیه اعداد صحیح
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3" >
        
          
          <label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    توابع نظریه اعداد
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3">
            <span class="md-nav__icon md-icon"></span>
            توابع نظریه اعداد
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/phi-function.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تابع فی اویلر
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/divisors.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تعداد مقسوم‌علیه‌ها / جمع مقسوم‌علیه‌ها
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_4" >
        
          
          <label class="md-nav__link" for="__nav_2_4" id="__nav_2_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    حساب پیمانه‌ای
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_4">
            <span class="md-nav__icon md-icon"></span>
            حساب پیمانه‌ای
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/module-inverse.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    وارون پیمانه‌ای
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/linear_congruence_equation.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    معادله همنهشتی خطی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/chinese-remainder-theorem.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    قضیه باقیمانده چینی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/garners-algorithm.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    الگوریتم Garner
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/factorial-modulo.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    فاکتوریل به پیمانه p
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/discrete-log.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    لگاریتم گسسته
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/primitive-root.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ریشه اولیه
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/discrete-root.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ریشه گسسته
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/montgomery_multiplication.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ضرب Montgomery
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_5" >
        
          
          <label class="md-nav__link" for="__nav_2_5" id="__nav_2_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    دستگاه‌های اعداد
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_5">
            <span class="md-nav__icon md-icon"></span>
            دستگاه‌های اعداد
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/balanced-ternary.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    سه‌سه‌ای متوازن
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/gray-code.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    کد گِرِی
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_6" >
        
          
          <label class="md-nav__link" for="__nav_2_6" id="__nav_2_6_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    متفرقه
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_6">
            <span class="md-nav__icon md-icon"></span>
            متفرقه
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/bit-manipulation.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    عملیات بیتی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/all-submasks.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    شمارش زیرماسک‌های یک بیت‌ماسک
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/big-integer.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    محاسبات با دقت دلخواه
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/fft.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تبدیل سریع فوریه
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/polynomial.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    عملیات روی چندجمله‌ای‌ها و سری‌ها
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/continued-fractions.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    کسرهای مسلسل
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/factoring-exp.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تجزیه توان
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    ساختمان داده‌ها
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            ساختمان داده‌ها
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    مبانی
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            مبانی
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="stack_queue_modification.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    پشته کمینه / صف کمینه
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="sparse-table.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    جدول پراکنده
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" checked>
        
          
          <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    درخت‌ها
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            درخت‌ها
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="disjoint_set_union.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ساختار داده اجتماع-جداگانه
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="fenwick.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    درخت فن‌ویک
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="sqrt_decomposition.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تجزیه رادیکالی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    درخت بازه‌ها
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="segment_tree.html" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    درخت بازه‌ها
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="فهرست موضوعات">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      فهرست موضوعات
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      ساده‌ترین شکل یک درخت بازه
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ساده‌ترین شکل یک درخت بازه">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      ساختار درخت بازه
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      ساختن درخت
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      پرس‌وجوهای مجموع
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      پرس‌وجوهای به‌روزرسانی
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#implementation" class="md-nav__link">
    <span class="md-ellipsis">
      پیاده‌سازی
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      پیاده‌سازی با حافظه بهینه
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      نسخه‌های پیشرفته درخت بازه
    </span>
  </a>
  
    <nav class="md-nav" aria-label="نسخه‌های پیشرفته درخت بازه">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      پرس‌وجوهای پیچیده‌تر
    </span>
  </a>
  
    <nav class="md-nav" aria-label="پرس‌وجوهای پیچیده‌تر">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      یافتن بیشینه
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      یافتن بیشینه و تعداد دفعات ظهور آن
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      محاسبه بزرگترین مقسوم‌علیه مشترک / کوچکترین مضرب مشترک
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#counting-zero-search-kth" class="md-nav__link">
    <span class="md-ellipsis">
      شمارش تعداد صفرها، جستجو برای k-امین صفر
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      جستجوی پیشوندی از آرایه با یک مقدار معین
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      جستجو برای اولین عنصر بزرگتر از یک مقدار معین
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      یافتن زیربازه‌ها با بیشترین مجموع
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      ذخیره کل زیرآرایه‌ها در هر رأس
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ذخیره کل زیرآرایه‌ها در هر رأس">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      یافتن کوچکترین عدد بزرگتر یا مساوی با یک عدد مشخص. بدون پرس‌وجوی تغییر.
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    <span class="md-ellipsis">
      یافتن کوچکترین عدد بزرگتر یا مساوی یک عدد مشخص. با پرس‌وجوهای تغییر.
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fractional-cascading" class="md-nav__link">
    <span class="md-ellipsis">
      یافتن کوچکترین عدد بزرگتر یا مساوی یک عدد مشخص. شتاب‌دهی با "آبشار کسری" (fractional cascading).
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    <span class="md-ellipsis">
      سایر تغییرات ممکن
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lazy-propagation" class="md-nav__link">
    <span class="md-ellipsis">
      به‌روزرسانی‌های بازه‌ای (انتشار با تأخیر یا Lazy Propagation)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="به‌روزرسانی‌های بازه‌ای (انتشار با تأخیر یا Lazy Propagation)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    <span class="md-ellipsis">
      افزودن در بازه‌ها
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    <span class="md-ellipsis">
      انتساب در بازه‌ها
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    <span class="md-ellipsis">
      افزودن در بازه‌ها، پرس‌وجوی بیشینه
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    <span class="md-ellipsis">
      تعمیم به ابعاد بالاتر
    </span>
  </a>
  
    <nav class="md-nav" aria-label="تعمیم به ابعاد بالاتر">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    <span class="md-ellipsis">
      درخت بازه ساده دوبعدی
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    <span class="md-ellipsis">
      فشرده‌سازی درخت بازه دوبعدی
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    <span class="md-ellipsis">
      حفظ تاریخچه مقادیر (درخت بازه پایدار)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="حفظ تاریخچه مقادیر (درخت بازه پایدار)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#k-" class="md-nav__link">
    <span class="md-ellipsis">
      یافتن k-امین کوچکترین عدد در یک بازه
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    <span class="md-ellipsis">
      درخت بازه پویا
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    <span class="md-ellipsis">
      مسائل تمرینی
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="treap.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تریپ (Treap)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="sqrt-tree.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    درخت رادیکالی (Sqrt Tree)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="randomized_heap.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    هیپ تصادفی
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    پیشرفته
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            پیشرفته
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="deleting_in_log_n.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    حذف از یک ساختمان داده در O(T(n) log n)
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    برنامه‌نویسی پویا
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            برنامه‌نویسی پویا
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dynamic_programming/intro-to-dp.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    مقدمه‌ای بر برنامه‌نویسی پویا
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dynamic_programming/knapsack.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    مسئله کوله‌پشتی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_3" >
        
          
          <label class="md-nav__link" for="__nav_4_3" id="__nav_4_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    بهینه‌سازی‌های برنامه‌نویسی پویا
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_3">
            <span class="md-nav__icon md-icon"></span>
            بهینه‌سازی‌های برنامه‌نویسی پویا
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dynamic_programming/divide-and-conquer-dp.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    برنامه‌نویسی پویای تقسیم و غلبه
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dynamic_programming/knuth-optimization.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    بهینه‌سازی Knuth
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_4" >
        
          
          <label class="md-nav__link" for="__nav_4_4" id="__nav_4_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    مسائل
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_4">
            <span class="md-nav__icon md-icon"></span>
            مسائل
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dynamic_programming/profile-dynamics.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    برنامه‌نویسی پویا روی پروفایل شکسته. مسئله "پارکت"
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dynamic_programming/zero_matrix.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    یافتن بزرگترین زیرماتریس صفر
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    پردازش رشته
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            پردازش رشته
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_1" >
        
          
          <label class="md-nav__link" for="__nav_5_1" id="__nav_5_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    مبانی
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_1">
            <span class="md-nav__icon md-icon"></span>
            مبانی
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/string-hashing.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    هشینگ رشته
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/rabin-karp.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    الگوریتم رابین-کارپ برای تطبیق رشته
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/prefix-function.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تابع پیشوندی - کنوث-موریس-پرت (KMP)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/z-function.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تابع Z
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/suffix-array.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    آرایه پسوندی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/aho_corasick.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    الگوریتم آهو-کوراسیک
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2" >
        
          
          <label class="md-nav__link" for="__nav_5_2" id="__nav_5_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    پیشرفته
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_2">
            <span class="md-nav__icon md-icon"></span>
            پیشرفته
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/suffix-tree-ukkonen.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    درخت پسوندی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/suffix-automaton.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    اتوماتای پسوندی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/lyndon_factorization.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تجزیه لیندون
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_3" >
        
          
          <label class="md-nav__link" for="__nav_5_3" id="__nav_5_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    مسائل
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5_3">
            <span class="md-nav__icon md-icon"></span>
            مسائل
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/expression_parsing.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تجزیه عبارت
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/manacher.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    الگوریتم ماناکر - یافتن تمام زیرپالیندروم‌ها در O(N)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../string/main_lorentz.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    یافتن تکرارها
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    جبر خطی
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            جبر خطی
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6_1" >
        
          
          <label class="md-nav__link" for="__nav_6_1" id="__nav_6_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    ماتریس‌ها
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_6_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6_1">
            <span class="md-nav__icon md-icon"></span>
            ماتریس‌ها
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../linear_algebra/linear-system-gauss.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    گاوس و دستگاه معادلات خطی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../linear_algebra/determinant-gauss.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    گاوس و دترمینان
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../linear_algebra/determinant-kraut.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Kraut و دترمینان
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../linear_algebra/rank-matrix.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    رتبه ماتریس
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    ترکیبیات
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            ترکیبیات
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_1" >
        
          
          <label class="md-nav__link" for="__nav_7_1" id="__nav_7_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    مبانی
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_7_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7_1">
            <span class="md-nav__icon md-icon"></span>
            مبانی
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../algebra/factorial-divisors.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    یافتن توان مقسوم‌علیه فاکتوریل
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/binomial-coefficients.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ضرایب دوجمله‌ای
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/catalan-numbers.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    اعداد کاتالان
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_2" >
        
          
          <label class="md-nav__link" for="__nav_7_2" id="__nav_7_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    تکنیک‌ها
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_7_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7_2">
            <span class="md-nav__icon md-icon"></span>
            تکنیک‌ها
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/inclusion-exclusion.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    اصل شمول و عدم شمول
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/burnside.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    لم برنساید / قضیه شمارش پولیا
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/stars_and_bars.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ستاره‌ها و خطوط
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/generating_combinations.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تولید تمام ترکیب‌های Kتایی
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_3" >
        
          
          <label class="md-nav__link" for="__nav_7_3" id="__nav_7_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    مسائل
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_7_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7_3">
            <span class="md-nav__icon md-icon"></span>
            مسائل
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/bishops-on-chessboard.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    قرار دادن فیل‌ها در صفحه شطرنج
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/bracket_sequences.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    دنباله‌های پرانتز متوازن
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../combinatorics/counting_labeled_graphs.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    شمارش گراف‌های برچسب‌دار
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    روش‌های عددی
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            روش‌های عددی
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_1" >
        
          
          <label class="md-nav__link" for="__nav_8_1" id="__nav_8_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    جستجو
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8_1">
            <span class="md-nav__icon md-icon"></span>
            جستجو
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../num_methods/binary_search.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    جستجوی دودویی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../num_methods/ternary_search.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    جستجوی سه‌سه‌ای
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../num_methods/roots_newton.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    روش نیوتن برای یافتن ریشه‌ها
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../num_methods/simulated_annealing.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تبرید شبیه‌سازی‌شده
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_2" >
        
          
          <label class="md-nav__link" for="__nav_8_2" id="__nav_8_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    انتگرال‌گیری
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8_2">
            <span class="md-nav__icon md-icon"></span>
            انتگرال‌گیری
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../num_methods/simpson-integration.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    انتگرال‌گیری با فرمول سیمپسون
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
        
          
          <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    هندسه
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9">
            <span class="md-nav__icon md-icon"></span>
            هندسه
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_1" >
        
          
          <label class="md-nav__link" for="__nav_9_1" id="__nav_9_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    عملیات مقدماتی
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_1">
            <span class="md-nav__icon md-icon"></span>
            عملیات مقدماتی
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/basic-geometry.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    هندسه پایه
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/segment-to-line.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    یافتن معادله خط یک پاره‌خط
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/lines-intersection.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    نقطه تقاطع خطوط
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/check-segments-intersection.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    بررسی تقاطع دو پاره‌خط
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/segments-intersection.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تقاطع پاره‌خط‌ها
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/circle-line-intersection.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تقاطع دایره و خط
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/circle-circle-intersection.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تقاطع دو دایره
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/tangents-to-two-circles.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    مماس‌های مشترک دو دایره
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/length-of-segments-union.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    طول اجتماع پاره‌خط‌ها
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_2" >
        
          
          <label class="md-nav__link" for="__nav_9_2" id="__nav_9_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    چندضلعی‌ها
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_2">
            <span class="md-nav__icon md-icon"></span>
            چندضلعی‌ها
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/oriented-triangle-area.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    مساحت جهت‌دار مثلث
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/area-of-simple-polygon.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    مساحت چندضلعی ساده
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/point-in-convex-polygon.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    بررسی تعلق نقاط به چندضلعی محدب در O(log N)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/minkowski.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    جمع مینکوفسکی چندضلعی‌های محدب
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/picks-theorem.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    قضیه پیک - مساحت چندضلعی‌های شبکه‌ای
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/lattice-points.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    نقاط شبکه‌ای چندضلعی غیرشبکه‌ای
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_3" >
        
          
          <label class="md-nav__link" for="__nav_9_3" id="__nav_9_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    پوش محدب
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_3">
            <span class="md-nav__icon md-icon"></span>
            پوش محدب
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/convex-hull.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ساخت پوش محدب
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/convex_hull_trick.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ترفند پوش محدب و درخت Li Chao
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_4" >
        
          
          <label class="md-nav__link" for="__nav_9_4" id="__nav_9_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    خط جاروب
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_4">
            <span class="md-nav__icon md-icon"></span>
            خط جاروب
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/intersecting_segments.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    جستجوی یک جفت پاره‌خط متقاطع
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_5" >
        
          
          <label class="md-nav__link" for="__nav_9_5" id="__nav_9_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    گراف‌های مسطح
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_5">
            <span class="md-nav__icon md-icon"></span>
            گراف‌های مسطح
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/planar.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    یافتن وجه‌های یک گراف مسطح
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/point-location.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    مکان‌یابی نقطه در O(log N)
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_6" >
        
          
          <label class="md-nav__link" for="__nav_9_6" id="__nav_9_6_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    متفرقه
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_9_6">
            <span class="md-nav__icon md-icon"></span>
            متفرقه
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/nearest_points.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    یافتن نزدیک‌ترین جفت نقاط
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/delaunay.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    مثلث‌بندی دلونی و دیاگرام ورونوی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/vertical_decomposition.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تجزیه عمودی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/halfplane-intersection.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تقاطع نیم‌صفحه‌ها - الگوریتم S&amp;I در O(N log N)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../geometry/manhattan-distance.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    فاصله منهتن
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10" >
        
          
          <label class="md-nav__link" for="__nav_10" id="__nav_10_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    گراف‌ها
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10">
            <span class="md-nav__icon md-icon"></span>
            گراف‌ها
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_1" >
        
          
          <label class="md-nav__link" for="__nav_10_1" id="__nav_10_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    پیمایش گراف
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_1">
            <span class="md-nav__icon md-icon"></span>
            پیمایش گراف
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/breadth-first-search.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    جستجوی اول سطح (BFS)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/depth-first-search.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    جستجوی اول عمق (DFS)
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_2" >
        
          
          <label class="md-nav__link" for="__nav_10_2" id="__nav_10_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    مؤلفه‌های همبندی، پل‌ها، نقاط مفصلی
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_2">
            <span class="md-nav__icon md-icon"></span>
            مؤلفه‌های همبندی، پل‌ها، نقاط مفصلی
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/search-for-connected-components.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    یافتن مؤلفه‌های همبندی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/bridge-searching.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    یافتن پل‌ها در O(N+M)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/bridge-searching-online.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    یافتن پل‌ها به صورت آنلاین
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/cutpoints.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    یافتن نقاط مفصلی در O(N+M)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/strongly-connected-components.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    مؤلفه‌های قویاً همبند و گراف انقباضی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/strong-orientation.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    جهت‌دهی قوی
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_3" >
        
          
          <label class="md-nav__link" for="__nav_10_3" id="__nav_10_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    کوتاه‌ترین مسیرهای تک‌مبدأ
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_3">
            <span class="md-nav__icon md-icon"></span>
            کوتاه‌ترین مسیرهای تک‌مبدأ
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/dijkstra.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    دایکسترا - یافتن کوتاه‌ترین مسیرها از یک رأس معین
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/dijkstra_sparse.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    دایکسترا روی گراف‌های خلوت
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/bellman_ford.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    بلمن-فورد - یافتن کوتاه‌ترین مسیرها با وزن‌های منفی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/01_bfs.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    جستجوی اول سطح صفر و یک (0-1 BFS)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/desopo_pape.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    الگوریتم D'Esopo-Pape
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_4" >
        
          
          <label class="md-nav__link" for="__nav_10_4" id="__nav_10_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    کوتاه‌ترین مسیرهای بین تمام زوج‌ها
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_4">
            <span class="md-nav__icon md-icon"></span>
            کوتاه‌ترین مسیرهای بین تمام زوج‌ها
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/all-pair-shortest-path-floyd-warshall.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    فلوید-وارشال - یافتن تمام کوتاه‌ترین مسیرها
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/fixed_length_paths.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تعداد مسیرها با طول ثابت / کوتاه‌ترین مسیرها با طول ثابت
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_5" >
        
          
          <label class="md-nav__link" for="__nav_10_5" id="__nav_10_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    درخت‌های پوشا
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_5">
            <span class="md-nav__icon md-icon"></span>
            درخت‌های پوشا
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/mst_prim.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    درخت پوشای کمینه - الگوریتم پریم
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/mst_kruskal.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    درخت پوشای کمینه - کروسکال
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/mst_kruskal_with_dsu.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    درخت پوشای کمینه - کروسکال با ساختار داده اجتماع-جداگانه
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/second_best_mst.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    دومین درخت پوشای کمینه بهتر - با استفاده از کروسکال و پایین‌ترین جد مشترک
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/kirchhoff-theorem.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    قضیه کیرشهف
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/pruefer_code.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    کد پروفر
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_6" >
        
          
          <label class="md-nav__link" for="__nav_10_6" id="__nav_10_6_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    دورها
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_6">
            <span class="md-nav__icon md-icon"></span>
            دورها
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/finding-cycle.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    بررسی غیرمدور بودن گراف و یافتن دور در O(M)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/finding-negative-cycle-in-graph.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    یافتن دور منفی در گراف
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/euler_path.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    مسیر اویلری
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_7" >
        
          
          <label class="md-nav__link" for="__nav_10_7" id="__nav_10_7_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    پایین‌ترین جد مشترک
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_7">
            <span class="md-nav__icon md-icon"></span>
            پایین‌ترین جد مشترک
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/lca.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    پایین‌ترین جد مشترک (LCA)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/lca_binary_lifting.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    پایین‌ترین جد مشترک - پرش دودویی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/lca_farachcoltonbender.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    پایین‌ترین جد مشترک - الگوریتم Farach-Colton و Bender
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/rmq_linear.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    حل RMQ با یافتن LCA
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/lca_tarjan.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    پایین‌ترین جد مشترک - الگوریتم آفلاین Tarjan
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_8" >
        
          
          <label class="md-nav__link" for="__nav_10_8" id="__nav_10_8_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    شار و مسائل مرتبط
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_8">
            <span class="md-nav__icon md-icon"></span>
            شار و مسائل مرتبط
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/edmonds_karp.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    شار بیشینه - فورد-فالکرسون و ادموندز-کارپ
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/push-relabel.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    شار بیشینه - الگوریتم Push-relabel
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/push-relabel-faster.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    شار بیشینه - الگوریتم بهبودیافته Push-relabel
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/dinic.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    شار بیشینه - الگوریتم دینیک
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/mpm.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    شار بیشینه - الگوریتم MPM
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/flow_with_demands.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    شار با تقاضا
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/min_cost_flow.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    شار با کمترین هزینه
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/Assignment-problem-min-flow.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    مسئله تخصیص
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_9" >
        
          
          <label class="md-nav__link" for="__nav_10_9" id="__nav_10_9_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    تطابق و مسائل مرتبط
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_9">
            <span class="md-nav__icon md-icon"></span>
            تطابق و مسائل مرتبط
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/bipartite-check.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    بررسی دوبخشی بودن گراف
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/kuhn_maximum_bipartite_matching.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    الگوریتم کوهن - تطابق بیشینه در گراف دوبخشی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/hungarian-algorithm.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    الگوریتم مجارستانی
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_10_10" >
        
          
          <label class="md-nav__link" for="__nav_10_10" id="__nav_10_10_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    متفرقه
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_10_10_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_10_10">
            <span class="md-nav__icon md-icon"></span>
            متفرقه
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/topological-sort.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    مرتب‌سازی توپولوژیک
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/edge_vertex_connectivity.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    همبندی یالی / همبندی رأسی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/tree_painting.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    رنگ‌آمیزی درخت
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/2SAT.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    دو-ارضاپذیری (2-SAT)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/hld.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    تجزیه سنگین-سبک
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11" >
        
          
          <label class="md-nav__link" for="__nav_11" id="__nav_11_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    متفرقه
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_11_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11">
            <span class="md-nav__icon md-icon"></span>
            متفرقه
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11_1" >
        
          
          <label class="md-nav__link" for="__nav_11_1" id="__nav_11_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    دنباله‌ها
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_11_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11_1">
            <span class="md-nav__icon md-icon"></span>
            دنباله‌ها
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../sequences/rmq.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    مسئله RMQ (پرس‌وجوی کمینه بازه - کوچکترین عنصر در یک بازه)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../sequences/longest_increasing_subsequence.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    طولانی‌ترین زیردنباله صعودی
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../others/maximum_average_segment.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    جستجوی زیربازه با بیشترین/کمترین مجموع
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../sequences/k-th.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    آماره مرتبه K-ام در O(N)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../sequences/mex.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    مسئله MEX (کمترین عنصر حذف‌شده در یک آرایه)
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11_2" >
        
          
          <label class="md-nav__link" for="__nav_11_2" id="__nav_11_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    نظریه بازی‌ها
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_11_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11_2">
            <span class="md-nav__icon md-icon"></span>
            نظریه بازی‌ها
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../game_theory/games_on_graphs.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    بازی‌ها روی گراف‌های دلخواه
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../game_theory/sprague-grundy-nim.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    قضیه اسپراگ-گراندی. نیم (Nim)
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11_3" >
        
          
          <label class="md-nav__link" for="__nav_11_3" id="__nav_11_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    زمان‌بندی‌ها
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_11_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11_3">
            <span class="md-nav__icon md-icon"></span>
            زمان‌بندی‌ها
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../schedules/schedule_one_machine.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    زمان‌بندی کارها روی یک ماشین
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../schedules/schedule_two_machines.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    زمان‌بندی کارها روی دو ماشین
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../schedules/schedule-with-completion-duration.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    زمان‌بندی بهینه کارها با توجه به مهلت‌ها و مدت‌زمانشان
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_11_4" >
        
          
          <label class="md-nav__link" for="__nav_11_4" id="__nav_11_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    متفرقه
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_11_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_11_4">
            <span class="md-nav__icon md-icon"></span>
            متفرقه
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../others/tortoise_and_hare.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    الگوریتم لاک‌پشت و خرگوش (تشخیص دور در لیست پیوندی)
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../others/josephus_problem.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    مسئله یوسف
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../others/15-puzzle.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    بازی پازل ۱۵: وجود راه‌حل
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../others/stern_brocot_tree_farey_sequences.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    درخت اشترن-بروکوت و دنباله‌های فارِی
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  <script type="text/javascript">
window.onload = function() {
	const newIssueURL = "https://github.com/cp-algorithms/cp-algorithms/issues/new";
  const issueTitle = "Problem on article " + "\u062f\u0631\u062e\u062a \u0628\u0627\u0632\u0647\u200c\u0647\u0627";
	const issueBody = `
 **Article:** [`+ "\u062f\u0631\u062e\u062a \u0628\u0627\u0632\u0647\u200c\u0647\u0627" + `](${window.location.href})

**Problem:**
<!--
Describe the issue of this article in detail.
-->
`;
  var issue_a = document.getElementById("report_issue_a");
  issue_a.href = `${newIssueURL}?` + `title=${encodeURIComponent(issueTitle)}&` + `body=${encodeURIComponent(issueBody)}`;
}
</script>

<a href="https://github.com/cp-algorithms/cp-algorithms/edit/main/src/data_structures/segment_tree.md" title="این صفحه را ویرایش کنید" class="md-content__button md-icon">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75z"/></svg>
</a>
<a id="report_issue_a" href="" title="Report a problem" class="md-content__button md-icon">
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 14h-2V9h2m0 9h-2v-2h2M1 21h22L12 2z"/></svg>
</a>
<a href="https://github.com/cp-algorithms/cp-algorithms/commits/main/src/data_structures/segment_tree.md" title="Page authors" class="md-content__button md-icon">
  <svg xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 24 24" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><g><rect fill="none" height="24" width="24"/></g><g><g><g><path d="M12,8.5c-0.91,0-2.75,0.46-2.75,1.38v4.62h1.5V19h2.5v-4.5h1.5V9.88C14.75,8.97,12.91,8.5,12,8.5z"/><path d="M12,2C6.47,2,2,6.47,2,12s4.47,10,10,10s10-4.48,10-10S17.52,2,12,2z M12,20c-4.42,0-8-3.58-8-8s3.58-8,8-8s8,3.58,8,8 S16.42,20,12,20z"/><circle cx="12" cy="6.5" r="1.5"/></g></g></g></svg>
</a>


<!-- Construct the dict of author's contribution percentage -->




  
  
  
    
  

  
  
  
    
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  
    
  

  
  
  
    
  

  
  
  
    
  
    
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  
    
  

  
  
  
    
  

  
  
  
    
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  

  
  
  
    
  
    
  
    
  
    
  

  
  
  
    
  
    
  

  
  
  
    
  



  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  

  
  
  




<!-- Date of last commit -->
<ul class="metadata page-metadata" data-bi-name="page info" lang="en-us" dir="ltr">

  اخرین بروزرسانی:
  <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-date" title="6 ژوئیهٔ 2025 13:36:29 UTC">6 ژوئیهٔ 2025</span>&emsp;

<!-- Tags -->

  
  
  
    
  


  
    <a href="../tags.html#tag:ai-translated" class="md-tag">
      AI Translated
    </a>
  

  
    <a href="https://e-maxx.ru/algo/segment_tree" class="md-tag">
      From: e-maxx.ru
    </a>
  

</ul>


<h1 id="segment-tree">درخت بازه (Segment Tree)<a class="headerlink" href="#segment-tree" title="Permanent link">&para;</a></h1>
<p>درخت بازه یک ساختمان داده است که اطلاعات مربوط به بازه‌های یک آرایه را به صورت درختی ذخیره می‌کند. این ساختار داده امکان پاسخ‌گویی بهینه به پرس‌وجوهای بازه‌ای روی یک آرایه را فراهم می‌کند و در عین حال به اندازه کافی انعطاف‌پذیر است تا امکان تغییر سریع آرایه را نیز بدهد.
این قابلیت‌ها شامل یافتن مجموع عناصر متوالی آرایه <span class="arithmatex">$a[l \dots r]$</span> یا یافتن عنصر کمینه در چنین بازه‌ای در زمان <span class="arithmatex">$O(\log n)$</span> است.
بین پاسخ به چنین پرس‌وجوهایی، درخت بازه امکان تغییر آرایه را با جایگزینی یک عنصر یا حتی تغییر عناصر یک زیربازه کامل فراهم می‌کند (مثلاً تخصیص یک مقدار به تمام عناصر <span class="arithmatex">$a[l \dots r]$</span> یا افزودن مقداری به تمام عناصر در آن زیربازه).</p>
<p>به طور کلی، درخت بازه یک ساختمان داده بسیار انعطاف‌پذیر است و تعداد زیادی از مسائل را می‌توان با آن حل کرد.
علاوه بر این، امکان اعمال عملیات پیچیده‌تر و پاسخ به پرس‌وجوهای پیچیده‌تر نیز وجود دارد (بخش <a href="segment_tree.html#advanced-versions-of-segment-trees">نسخه‌های پیشرفته درخت بازه</a> را ببینید).
به‌ویژه، درخت بازه را می‌توان به راحتی به ابعاد بالاتر تعمیم داد.
برای مثال، با یک درخت بازه دو‌بعدی می‌توانید به پرس‌وجوهای مجموع یا کمینه روی یک زیرمستطیل از یک ماتریس در زمان <span class="arithmatex">$O(\log^2 n)$</span> پاسخ دهید.</p>
<p>یکی از ویژگی‌های مهم درخت بازه این است که تنها به مقدار حافظه خطی نیاز دارد.
درخت بازه استاندارد برای کار بر روی آرایه‌ای به اندازه <span class="arithmatex">$n$</span> به <span class="arithmatex">$4n$</span> رأس نیاز دارد.</p>
<h2 id="_1">ساده‌ترین شکل یک درخت بازه<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<p>برای شروع، ساده‌ترین شکل یک درخت بازه را در نظر می‌گیریم.
می‌خواهیم به پرس‌وجوهای مجموع به صورت بهینه پاسخ دهیم.
تعریف رسمی وظیفه ما به این صورت است:
با داشتن آرایه <span class="arithmatex">$a[0 \dots n-1]$</span>، درخت بازه باید قادر به یافتن مجموع عناصر بین اندیس‌های <span class="arithmatex">$l$</span> و <span class="arithmatex">$r$</span> (یعنی محاسبه مجموع <span class="arithmatex">$\sum_{i=l}^r a[i]$</span>) و همچنین مدیریت تغییر مقادیر عناصر آرایه (یعنی انجام انتساب‌هایی به شکل <span class="arithmatex">$a[i] = x$</span>) باشد.
درخت بازه باید بتواند <strong>هر دو</strong> پرس‌وجو را در زمان <span class="arithmatex">$O(\log n)$</span> پردازش کند.</p>
<p>این یک بهبود نسبت به رویکردهای ساده‌تر است.
یک پیاده‌سازی ساده با آرایه - فقط با استفاده از یک آرایه معمولی - می‌تواند عناصر را در زمان <span class="arithmatex">$O(1)$</span> به‌روزرسانی کند، اما برای محاسبه هر پرس‌وجوی مجموع به زمان <span class="arithmatex">$O(n)$</span> نیاز دارد.
و مجموع‌های پیشوندی از پیش محاسبه‌شده می‌توانند پرس‌وجوهای مجموع را در زمان <span class="arithmatex">$O(1)$</span> محاسبه کنند، اما به‌روزرسانی یک عنصر آرایه به <span class="arithmatex">$O(n)$</span> تغییر در مجموع‌های پیشوندی نیاز دارد.</p>
<h3 id="_2">ساختار درخت بازه<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<p>می‌توانیم در مورد بازه‌های آرایه از رویکرد تقسیم و غلبه استفاده کنیم.
ما مجموع عناصر کل آرایه، یعنی مجموع بازه <span class="arithmatex">$a[0 \dots n-1]$</span> را محاسبه و ذخیره می‌کنیم.
سپس آرایه را به دو نیمه <span class="arithmatex">$a[0 \dots n/2-1]$</span> و <span class="arithmatex">$a[n/2 \dots n-1]$</span> تقسیم کرده و مجموع هر نیمه را محاسبه و ذخیره می‌کنیم.
هر یک از این دو نیمه به نوبه خود به دو نیمه تقسیم می‌شوند و این کار تا زمانی ادامه می‌یابد که همه بازه‌ها به اندازه <span class="arithmatex">$۱$</span> برسند.</p>
<p>می‌توانیم این بازه‌ها را به صورت یک درخت دودویی در نظر بگیریم:
ریشه این درخت بازه <span class="arithmatex">$a[0 \dots n-1]$</span> است و هر رأس (به جز رأس‌های برگ) دقیقاً دو فرزند دارد.
به همین دلیل این ساختمان داده «درخت بازه» نامیده می‌شود، هرچند در بیشتر پیاده‌سازی‌ها، درخت به صراحت ساخته نمی‌شود (بخش <a href="segment_tree.html#implementation">پیاده‌سازی</a> را ببینید).</p>
<p>در اینجا یک نمایش تصویری از چنین درخت بازه‌ای روی آرایه <span class="arithmatex">$a = [1, 3, -2, 8, -7]$</span> آمده است:</p>
<p><img alt="&quot;درخت بازه برای مجموع&quot;" src="sum-segment-tree.png" /></p>
<p>از این توصیف کوتاه از ساختمان داده، می‌توانیم نتیجه بگیریم که یک درخت بازه تنها به تعداد خطی رأس نیاز دارد.
سطح اول درخت شامل یک گره (ریشه) است، سطح دوم شامل دو رأس، در سطح سوم شامل چهار رأس خواهد بود، تا زمانی که تعداد رأس‌ها به <span class="arithmatex">$n$</span> برسد.
بنابراین تعداد رأس‌ها در بدترین حالت را می‌توان با مجموع <span class="arithmatex">$1 + 2 + 4 + \dots + 2^{\lceil\log_2 n\rceil} \lt 2^{\lceil\log_2 n\rceil + 1} \lt 4n$</span> تخمین زد.</p>
<p>شایان ذکر است که هرگاه <span class="arithmatex">$n$</span> توانی از دو نباشد، تمام سطوح درخت بازه به طور کامل پر نخواهند شد.
می‌توانیم این رفتار را در تصویر مشاهده کنیم.
فعلاً می‌توانیم این واقعیت را فراموش کنیم، اما بعداً در حین پیاده‌سازی اهمیت پیدا می‌کند.</p>
<p>ارتفاع درخت بازه <span class="arithmatex">$O(\log n)$</span> است، زیرا هنگام پایین رفتن از ریشه به سمت برگ‌ها، اندازه بازه‌ها تقریباً نصف می‌شود.</p>
<h3 id="_3">ساختن درخت<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p>قبل از ساختن درخت بازه، باید تصمیم بگیریم:</p>
<ol>
<li><em>مقدار</em>ی که در هر گره درخت بازه ذخیره می‌شود.
   برای مثال، در یک درخت بازه برای مجموع، یک گره مجموع عناصر در بازه خود <span class="arithmatex">$[l, r]$</span> را ذخیره می‌کند.</li>
<li>عملیات <em>ادغام</em> که دو گره خواهر و برادر را در یک درخت بازه ادغام می‌کند.
   برای مثال، در یک درخت بازه برای مجموع، دو گره مربوط به بازه‌های <span class="arithmatex">$a[l_1 \dots r_1]$</span> و <span class="arithmatex">$a[l_2 \dots r_2]$</span> با جمع کردن مقادیرشان در یک گره مربوط به بازه <span class="arithmatex">$a[l_1 \dots r_2]$</span> ادغام می‌شوند.</li>
</ol>
<p>توجه داشته باشید که یک رأس، «رأس برگ» است اگر بازه مربوط به آن فقط یک مقدار از آرایه اصلی را پوشش دهد. این رأس در پایین‌ترین سطح درخت بازه قرار دارد. مقدار آن برابر با عنصر (مربوطه) <span class="arithmatex">$a[i]$</span> خواهد بود.</p>
<p>حال، برای ساخت درخت بازه، از سطح پایین (رأس‌های برگ) شروع کرده و مقادیر مربوط به آن‌ها را تخصیص می‌دهیم. بر اساس این مقادیر، می‌توانیم مقادیر سطح بالاتر را با استفاده از تابع <code>merge</code> محاسبه کنیم.
و بر اساس آن‌ها، می‌توانیم مقادیر سطح بالاتر را محاسبه کرده و این روند را تا رسیدن به رأس ریشه تکرار کنیم.</p>
<p>توصیف این عملیات به صورت بازگشتی در جهت دیگر، یعنی از رأس ریشه به رأس‌های برگ، راحت‌تر است. رویه ساخت، اگر روی یک رأس غیربرگ فراخوانی شود، کارهای زیر را انجام می‌دهد:</p>
<ol>
<li>به صورت بازگشتی مقادیر دو رأس فرزند را می‌سازد</li>
<li>مقادیر محاسبه‌شده این فرزندان را ادغام می‌کند.</li>
</ol>
<p>ما ساخت را از رأس ریشه شروع می‌کنیم، و بنابراین، می‌توانیم کل درخت بازه را محاسبه کنیم.</p>
<p>پیچیدگی زمانی این ساخت <span class="arithmatex">$O(n)$</span> است، با فرض اینکه عملیات ادغام زمان ثابتی داشته باشد (عملیات ادغام <span class="arithmatex">$n$</span> بار فراخوانی می‌شود، که برابر با تعداد گره‌های داخلی در درخت بازه است).</p>
<h3 id="_4">پرس‌وجوهای مجموع<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p>فعلاً می‌خواهیم به پرس‌وجوهای مجموع پاسخ دهیم. به عنوان ورودی، دو عدد صحیح <span class="arithmatex">$l$</span> و <span class="arithmatex">$r$</span> دریافت می‌کنیم و باید مجموع بازه <span class="arithmatex">$a[l \dots r]$</span> را در زمان <span class="arithmatex">$O(\log n)$</span> محاسبه کنیم.</p>
<p>برای انجام این کار، درخت بازه را پیمایش کرده و از مجموع‌های از پیش محاسبه‌شده بازه‌ها استفاده می‌کنیم.
فرض کنیم در حال حاضر در رأسی هستیم که بازه <span class="arithmatex">$a[tl \dots tr]$</span> را پوشش می‌دهد.
سه حالت ممکن وجود دارد.</p>
<p>ساده‌ترین حالت زمانی است که بازه <span class="arithmatex">$a[l \dots r]$</span> با بازه مربوط به رأس فعلی برابر باشد (یعنی <span class="arithmatex">$a[l \dots r] = a[tl \dots tr]$</span>)، در این صورت کار تمام است و می‌توانیم مجموع از پیش محاسبه‌شده‌ای که در رأس ذخیره شده است را برگردانیم.</p>
<p>حالت دیگر این است که بازه پرس‌وجو به طور کامل در دامنه فرزند چپ یا راست قرار گیرد.
به یاد بیاورید که فرزند چپ بازه <span class="arithmatex">$a[tl \dots tm]$</span> و فرزند راست بازه <span class="arithmatex">$a[tm + 1 \dots tr]$</span> را با <span class="arithmatex">$tm = (tl + tr) / 2$</span> پوشش می‌دهد.
در این حالت می‌توانیم به سادگی به رأس فرزندی برویم که بازه‌اش، بازه پرس‌وجو را پوشش می‌دهد و الگوریتم توصیف‌شده را با آن رأس اجرا کنیم.</p>
<p>و در نهایت حالت آخر، بازه پرس‌وجو با هر دو فرزند تلاقی دارد.
در این حالت چاره‌ای جز انجام دو فراخوانی بازگشتی، یکی برای هر فرزند، نداریم.
ابتدا به فرزند چپ می‌رویم، یک پاسخ جزئی برای این رأس محاسبه می‌کنیم (یعنی مجموع مقادیر تلاقی بین بازه پرس‌وجو و بازه فرزند چپ)، سپس به فرزند راست می‌رویم، پاسخ جزئی را با استفاده از آن رأس محاسبه می‌کنیم و سپس پاسخ‌ها را با جمع کردنشان ترکیب می‌کنیم.
به عبارت دیگر، از آنجا که فرزند چپ بازه <span class="arithmatex">$a[tl \dots tm]$</span> و فرزند راست بازه <span class="arithmatex">$a[tm+1 \dots tr]$</span> را نشان می‌دهد، پرس‌وجوی مجموع <span class="arithmatex">$a[l \dots tm]$</span> را با استفاده از فرزند چپ و پرس‌وجوی مجموع <span class="arithmatex">$a[tm+1 \dots r]$</span> را با استفاده از فرزند راست محاسبه می‌کنیم.</p>
<p>بنابراین پردازش یک پرس‌وجوی مجموع، یک تابع است که به صورت بازگشتی خود را یک بار با فرزند چپ یا راست (بدون تغییر مرزهای پرس‌وجو) یا دو بار، یک بار برای چپ و یک بار برای راست (با تقسیم پرس‌وجو به دو زیرپرس‌وجو) فراخوانی می‌کند.
و بازگشت زمانی پایان می‌یابد که مرزهای بازه پرس‌وجوی فعلی با مرزهای بازه رأس فعلی منطبق شوند.
در آن حالت، پاسخ، مقدار از پیش محاسبه‌شده مجموع این بازه خواهد بود که در درخت ذخیره شده است.</p>
<p>به عبارت دیگر، محاسبه پرس‌وجو یک پیمایش از درخت است که در تمام شاخه‌های لازم درخت پخش می‌شود و از مقادیر مجموع از پیش محاسبه‌شده بازه‌ها در درخت استفاده می‌کند.</p>
<p>بدیهی است که پیمایش را از رأس ریشه درخت بازه شروع خواهیم کرد.</p>
<p>این رویه در تصویر زیر نشان داده شده است.
دوباره از آرایه <span class="arithmatex">$a = [1, 3, -2, 8, -7]$</span> استفاده شده و اینجا می‌خواهیم مجموع <span class="arithmatex">$\sum_{i=2}^4 a[i]$</span> را محاسبه کنیم.
رأس‌های رنگی بازدید می‌شوند و ما از مقادیر از پیش محاسبه‌شده رأس‌های سبز استفاده خواهیم کرد.
این کار نتیجه $ -2 + 1 = -1$ را به ما می‌دهد.</p>
<p><img alt="&quot;پرس‌وجوی درخت بازه برای مجموع&quot;" src="sum-segment-tree-query.png" /></p>
<p>چرا پیچیدگی این الگوریتم <span class="arithmatex">$O(\log n)$</span> است؟
برای نشان دادن این پیچیدگی، به هر سطح از درخت نگاه می‌کنیم.
معلوم می‌شود که برای هر سطح، ما بیش از چهار رأس را بازدید نمی‌کنیم.
و از آنجایی که ارتفاع درخت <span class="arithmatex">$O(\log n)$</span> است، به زمان اجرای مطلوب می‌رسیم.</p>
<p>می‌توانیم با استقرا نشان دهیم که این گزاره (حداکثر چهار رأس در هر سطح) درست است.
در سطح اول، فقط یک رأس، یعنی رأس ریشه، را بازدید می‌کنیم، بنابراین در اینجا کمتر از چهار رأس بازدید می‌شود.
حال به یک سطح دلخواه نگاه می‌کنیم.
طبق فرض استقرا، حداکثر چهار رأس را بازدید می‌کنیم.
اگر حداکثر دو رأس را بازدید کنیم، سطح بعدی حداکثر چهار رأس خواهد داشت. این بدیهی است، زیرا هر رأس حداکثر می‌تواند دو فراخوانی بازگشتی ایجاد کند.
بنابراین فرض کنیم که سه یا چهار رأس را در سطح فعلی بازدید می‌کنیم.
از این رأس‌ها، رأس‌های میانی را با دقت بیشتری تحلیل می‌کنیم.
از آنجایی که پرس‌وجوی مجموع، مجموع یک زیرآرایه پیوسته را می‌خواهد، می‌دانیم که بازه‌های مربوط به رأس‌های بازدید شده در وسط، به طور کامل توسط بازه پرس‌وجوی مجموع پوشش داده خواهند شد.
بنابراین این رأس‌ها هیچ فراخوانی بازگشتی انجام نخواهند داد.
پس فقط چپ‌ترین و راست‌ترین رأس‌ها پتانسیل انجام فراخوانی‌های بازگشتی را دارند.
و آنها حداکثر چهار فراخوانی بازگشتی ایجاد خواهند کرد، بنابراین سطح بعدی نیز این گزاره را برآورده خواهد کرد.
می‌توانیم بگوییم یک شاخه به مرز چپ پرس‌وجو نزدیک می‌شود و شاخه دوم به مرز راست آن.</p>
<p>بنابراین در مجموع حداکثر <span class="arithmatex">$4 \log n$</span> رأس بازدید می‌کنیم و این برابر با زمان اجرای <span class="arithmatex">$O(\log n)$</span> است.</p>
<p>در نتیجه، پرس‌وجو با تقسیم بازه ورودی به چندین زیربازه که مجموع‌هایشان قبلاً در درخت محاسبه و ذخیره شده‌اند، کار می‌کند.
و اگر هر زمان که بازه پرس‌وجو با بازه رأس منطبق شد، تقسیم‌بندی را متوقف کنیم، تنها به <span class="arithmatex">$O(\log n)$</span> چنین بازه‌ای نیاز خواهیم داشت که این کارایی درخت بازه را نشان می‌دهد.</p>
<h3 id="_5">پرس‌وجوهای به‌روزرسانی<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<p>حالا می‌خواهیم یک عنصر خاص در آرایه را تغییر دهیم، فرض کنید می‌خواهیم انتساب <span class="arithmatex">$a[i] = x$</span> را انجام دهیم.
و باید درخت بازه را بازسازی کنیم تا با آرایه جدید و اصلاح‌شده مطابقت داشته باشد.</p>
<p>این پرس‌وجو از پرس‌وجوی مجموع ساده‌تر است.
هر سطح از یک درخت بازه یک افراز از آرایه را تشکیل می‌دهد.
بنابراین یک عنصر <span class="arithmatex">$a[i]$</span> فقط به یک بازه از هر سطح کمک می‌کند.
در نتیجه، تنها <span class="arithmatex">$O(\log n)$</span> رأس نیاز به به‌روزرسانی دارند.</p>
<p>به راحتی می‌توان دید که درخواست به‌روزرسانی را می‌توان با یک تابع بازگشتی پیاده‌سازی کرد.
این تابع رأس فعلی درخت را به عنوان پارامتر دریافت می‌کند و به صورت بازگشتی خود را با یکی از دو رأس فرزند (آنکه <span class="arithmatex">$a[i]$</span> را در بازه‌اش دارد) فراخوانی می‌کند و پس از آن مقدار مجموع خود را، مشابه آنچه در متد ساخت انجام می‌شود، دوباره محاسبه می‌کند (یعنی به عنوان مجموع دو فرزندش).</p>
<p>باز هم در اینجا یک تصویرسازی با استفاده از همان آرایه آمده است.
در اینجا ما به‌روزرسانی <span class="arithmatex">$a[2] = 3$</span> را انجام می‌دهیم.
رأس‌های سبز، رأس‌هایی هستند که ما بازدید و به‌روزرسانی می‌کنیم.</p>
<p><img alt="&quot;به‌روزرسانی درخت بازه برای مجموع&quot;" src="sum-segment-tree-update.png" /></p>
<h3 id="implementation">پیاده‌سازی<a class="headerlink" href="#implementation" title="Permanent link">&para;</a></h3>
<p>ملاحظه اصلی این است که چگونه درخت بازه را ذخیره کنیم.
البته می‌توانیم یک ساختار <code>Vertex</code> تعریف کرده و اشیایی بسازیم که مرزهای بازه، مجموع آن و علاوه بر آن اشاره‌گرهایی به رأس‌های فرزندش را ذخیره کنند.
با این حال، این کار نیاز به ذخیره اطلاعات اضافی زیادی در قالب اشاره‌گرها دارد.
ما از یک ترفند ساده برای کارآمدتر کردن این کار با استفاده از یک <em>ساختار داده ضمنی</em> استفاده خواهیم کرد: فقط ذخیره مجموع‌ها در یک آرایه.
(یک روش مشابه برای هیپ‌های دودویی استفاده می‌شود).
مجموع رأس ریشه در اندیس ۱، مجموع دو رأس فرزندش در اندیس‌های ۲ و ۳، مجموع فرزندان آن دو رأس در اندیس‌های ۴ تا ۷ و به همین ترتیب.
با اندیس‌گذاری از ۱، به راحتی فرزند چپ یک رأس در اندیس <span class="arithmatex">$i$</span> در اندیس <span class="arithmatex">$2i$</span> و فرزند راست آن در اندیس <span class="arithmatex">$2i + 1$</span> ذخیره می‌شود.
به طور معادل، والد یک رأس در اندیس <span class="arithmatex">$i$</span> در <span class="arithmatex">$i/2$</span> (تقسیم صحیح) ذخیره می‌شود.</p>
<p>این کار پیاده‌سازی را بسیار ساده می‌کند.
نیازی به ذخیره ساختار درخت در حافظه نداریم.
این ساختار به صورت ضمنی تعریف شده است.
ما فقط به یک آرایه نیاز داریم که شامل مجموع تمام بازه‌ها باشد.</p>
<p>همانطور که قبلاً ذکر شد، حداکثر <span class="arithmatex">$4n$</span> رأس باید ذخیره کنیم.
ممکن است کمتر باشد، اما برای راحتی همیشه یک آرایه به اندازه <span class="arithmatex">$4n$</span> اختصاص می‌دهیم.
برخی از عناصر در آرایه مجموع وجود خواهند داشت که با هیچ رأسی در درخت واقعی مطابقت ندارند، اما این موضوع پیاده‌سازی را پیچیده نمی‌کند.</p>
<p>بنابراین، ما درخت بازه را به سادگی به عنوان یک آرایه <span class="arithmatex">$t[]$</span> با اندازه چهار برابر اندازه ورودی <span class="arithmatex">$n$</span> ذخیره می‌کنیم:</p>
<div class="cpp highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">MAXN</span><span class="p">];</span>
</code></pre></div>
<p>رویه ساخت درخت بازه از یک آرایه داده شده <span class="arithmatex">$a[]$</span> به این صورت است:
این یک تابع بازگشتی با پارامترهای <span class="arithmatex">$a[]$</span> (آرایه ورودی)، <span class="arithmatex">$v$</span> (اندیس رأس فعلی) و مرزهای <span class="arithmatex">$tl$</span> و <span class="arithmatex">$tr$</span> بازه فعلی است.
در برنامه اصلی این تابع با پارامترهای رأس ریشه فراخوانی می‌شود: <span class="arithmatex">$v = 1$</span>، <span class="arithmatex">$tl = 0$</span> و <span class="arithmatex">$tr = n - 1$</span>.</p>
<div class="cpp highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">tl</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">);</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>علاوه بر این، تابع پاسخ به پرس‌وجوهای مجموع نیز یک تابع بازگشتی است که به عنوان پارامتر اطلاعات مربوط به رأس/بازه فعلی (یعنی اندیس <span class="arithmatex">$v$</span> و مرزهای <span class="arithmatex">$tl$</span> و <span class="arithmatex">$tr$</span>) و همچنین اطلاعات مربوط به مرزهای پرس‌وجو، <span class="arithmatex">$l$</span> و <span class="arithmatex">$r$</span> را دریافت می‌کند.
برای ساده‌سازی کد، این تابع همیشه دو فراخوانی بازگشتی انجام می‌دهد، حتی اگر فقط یکی لازم باشد - در آن صورت فراخوانی بازگشتی اضافی <span class="arithmatex">$l &gt; r$</span> خواهد داشت، و این به راحتی با یک بررسی اضافی در ابتدای تابع قابل تشخیص است.</p>
<div class="cpp highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">))</span>
<span class="w">           </span><span class="o">+</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>در نهایت پرس‌وجوی به‌روزرسانی. این تابع نیز اطلاعات مربوط به رأس/بازه فعلی و علاوه بر آن پارامتر پرس‌وجوی به‌روزرسانی (یعنی موقعیت عنصر و مقدار جدید آن) را دریافت می‌کند.</p>
<div class="cpp highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_val</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tm</span><span class="p">)</span>
<span class="w">            </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_6">پیاده‌سازی با حافظه بهینه<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h3>
<p>بیشتر افراد از پیاده‌سازی بخش قبل استفاده می‌کنند. اگر به آرایه <code>t</code> نگاه کنید، می‌بینید که شماره‌گذاری گره‌های درخت را به ترتیب پیمایش BFS (پیمایش سطح به سطح) دنبال می‌کند.
با استفاده از این پیمایش، فرزندان رأس <span class="arithmatex">$v$</span> به ترتیب <span class="arithmatex">$2v$</span> و <span class="arithmatex">$2v + 1$</span> هستند.
اما اگر <span class="arithmatex">$n$</span> توانی از دو نباشد، این روش برخی از اندیس‌ها را نادیده گرفته و بخش‌هایی از آرایه <code>t</code> را بدون استفاده باقی می‌گذارد.
مصرف حافظه به <span class="arithmatex">$4n$</span> محدود می‌شود، در حالی که یک درخت بازه از آرایه‌ای با <span class="arithmatex">$n$</span> عنصر تنها به <span class="arithmatex">$2n - 1$</span> رأس نیاز دارد.</p>
<p>با این حال، می‌توان آن را کاهش داد.
ما رأس‌های درخت را به ترتیب پیمایش تور اویلر (پیمایش پیش‌ترتیب) دوباره شماره‌گذاری می‌کنیم و همه این رأس‌ها را کنار هم می‌نویسیم.</p>
<p>بیایید به رأسی در اندیس <span class="arithmatex">$v$</span> نگاه کنیم، و فرض کنیم مسئول بازه <span class="arithmatex">$[l, r]$</span> است و <span class="arithmatex">$mid = \dfrac{l + r}{2}$</span>.
واضح است که فرزند چپ اندیس <span class="arithmatex">$v + 1$</span> را خواهد داشت.
فرزند چپ مسئول بازه <span class="arithmatex">$[l, mid]$</span> است، یعنی در مجموع <span class="arithmatex">$2 * (mid - l + 1) - 1$</span> رأس در زیردرخت فرزند چپ وجود خواهد داشت.
بنابراین می‌توانیم اندیس فرزند راست <span class="arithmatex">$v$</span> را محاسبه کنیم. اندیس آن <span class="arithmatex">$v + 2 * (mid - l + 1)$</span> خواهد بود.
با این شماره‌گذاری به کاهشی در حافظه مورد نیاز به <span class="arithmatex">$2n$</span> دست می‌یابیم.</p>
<h2 id="_7"><a name="advanced-versions-of-segment-trees"></a>نسخه‌های پیشرفته درخت بازه<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h2>
<p>یک درخت بازه ساختار داده بسیار انعطاف‌پذیری است و امکان تغییرات و توسعه‌ها در جهات مختلف را فراهم می‌کند.
بیایید سعی کنیم آنها را در زیر دسته‌بندی کنیم.</p>
<h3 id="_8">پرس‌وجوهای پیچیده‌تر<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<p>تغییر درخت بازه در جهتی که پرس‌وجوهای مختلفی را محاسبه کند (مثلاً محاسبه کمینه / بیشینه به جای مجموع) می‌تواند کاملاً آسان باشد، اما همچنین می‌تواند بسیار غیربدیهی باشد.</p>
<h4 id="_9">یافتن بیشینه<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h4>
<p>بیایید شرط مسئله توصیف شده در بالا را کمی تغییر دهیم: به جای پرس‌وجوی مجموع، اکنون پرس‌وجوهای بیشینه را انجام خواهیم داد.</p>
<p>درخت دقیقاً همان ساختاری را خواهد داشت که در بالا توصیف شد.
ما فقط باید نحوه محاسبه <span class="arithmatex">$t[v]$</span> را در توابع <span class="arithmatex">$\text{build}$</span> و <span class="arithmatex">$\text{update}$</span> تغییر دهیم.
<span class="arithmatex">$t[v]$</span> اکنون بیشینه بازه مربوطه را ذخیره خواهد کرد.
و همچنین باید محاسبه مقدار بازگشتی تابع <span class="arithmatex">$\text{sum}$</span> را تغییر دهیم (جایگزین کردن جمع با بیشینه).</p>
<p>البته این مسئله را می‌توان به راحتی به محاسبه کمینه به جای بیشینه تغییر داد.</p>
<p>به جای نشان دادن پیاده‌سازی این مسئله، پیاده‌سازی نسخه پیچیده‌تری از این مسئله در بخش بعدی ارائه خواهد شد.</p>
<h4 id="_10">یافتن بیشینه و تعداد دفعات ظهور آن<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h4>
<p>این وظیفه بسیار شبیه به وظیفه قبلی است.
علاوه بر یافتن بیشینه، باید تعداد رخدادهای آن را نیز پیدا کنیم.</p>
<p>برای حل این مسئله، یک جفت عدد در هر رأس درخت ذخیره می‌کنیم:
علاوه بر بیشینه، تعداد رخدادهای آن را نیز در بازه مربوطه ذخیره می‌کنیم.
تعیین جفت صحیح برای ذخیره در <span class="arithmatex">$t[v]$</span> هنوز هم می‌تواند در زمان ثابت با استفاده از اطلاعات جفت‌های ذخیره شده در رأس‌های فرزند انجام شود.
ترکیب دو چنین جفتی باید در یک تابع جداگانه انجام شود، زیرا این عملیاتی است که ما هنگام ساخت درخت، هنگام پاسخ به پرس‌وجوهای بیشینه و هنگام انجام تغییرات انجام خواهیم داد.</p>
<div class="cpp highlight"><pre><span></span><code><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">MAXN</span><span class="p">];</span>

<span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">combine</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">first</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">make_pair</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">build</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_pair</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">tl</span><span class="p">],</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">);</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">combine</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">get_max</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">make_pair</span><span class="p">(</span><span class="o">-</span><span class="n">INF</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">combine</span><span class="p">(</span><span class="n">get_max</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">)),</span><span class="w"> </span>
<span class="w">                   </span><span class="n">get_max</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_pair</span><span class="p">(</span><span class="n">new_val</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tm</span><span class="p">)</span>
<span class="w">            </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">combine</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="_11">محاسبه بزرگترین مقسوم‌علیه مشترک / کوچکترین مضرب مشترک<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h4>
<p>در این مسئله می‌خواهیم ب.م.م / ک.م.م تمام اعداد بازه‌های داده شده از آرایه را محاسبه کنیم.</p>
<p>این نوع جالب از درخت بازه را می‌توان دقیقاً به همان روشی که درختان بازه برای پرس‌وجوهای مجموع / کمینه / بیشینه استخراج کردیم، حل کرد:
کافی است ب.م.م / ک.م.م رأس مربوطه را در هر رأس درخت ذخیره کنیم.
ترکیب دو رأس را می‌توان با محاسبه ب.م.م / ک.م.م هر دو رأس انجام داد.</p>
<h4 id="counting-zero-search-kth">شمارش تعداد صفرها، جستجو برای <span class="arithmatex">$k$</span>-امین صفر<a class="headerlink" href="#counting-zero-search-kth" title="Permanent link">&para;</a></h4>
<p>در این مسئله می‌خواهیم تعداد صفرها را در یک بازه مشخص پیدا کنیم و علاوه بر آن، با استفاده از یک تابع دوم، اندیس <span class="arithmatex">$k$</span>-امین صفر را پیدا کنیم.</p>
<p>باز هم باید مقادیر ذخیره شده در درخت را کمی تغییر دهیم:
این بار تعداد صفرها را در هر بازه در <span class="arithmatex">$t[]$</span> ذخیره خواهیم کرد.
کاملاً واضح است که چگونه توابع <span class="arithmatex">$\text{build}$</span>، <span class="arithmatex">$\text{update}$</span> و <span class="arithmatex">$\text{count_zero}$</span> را پیاده‌سازی کنیم، می‌توانیم به سادگی از ایده‌های مسئله پرس‌وجوی مجموع استفاده کنیم.
بنابراین بخش اول مسئله را حل کردیم.</p>
<p>اکنون یاد می‌گیریم چگونه مسئله یافتن <span class="arithmatex">$k$</span>-امین صفر در آرایه <span class="arithmatex">$a[]$</span> را حل کنیم.
برای انجام این کار، از درخت بازه پایین می‌رویم، از رأس ریشه شروع می‌کنیم و هر بار به فرزند چپ یا راست حرکت می‌کنیم، بسته به اینکه کدام بازه شامل <span class="arithmatex">$k$</span>-امین صفر است.
برای تصمیم‌گیری در مورد اینکه به کدام فرزند برویم، کافی است به تعداد صفرهای موجود در بازه مربوط به رأس چپ نگاه کنیم.
اگر این تعداد از پیش محاسبه‌شده بزرگتر یا مساوی <span class="arithmatex">$k$</span> باشد، لازم است به فرزند چپ برویم و در غیر این صورت به فرزند راست.
توجه داشته باشید، اگر فرزند راست را انتخاب کنیم، باید تعداد صفرهای فرزند چپ را از <span class="arithmatex">$k$</span> کم کنیم.</p>
<p>در پیاده‌سازی می‌توانیم حالت خاصی که <span class="arithmatex">$a[]$</span> کمتر از <span class="arithmatex">$k$</span> صفر دارد را با بازگرداندن -1 مدیریت کنیم.</p>
<div class="cpp highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">find_kth</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">tl</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">find_kth</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">find_kth</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="_12">جستجوی پیشوندی از آرایه با یک مقدار معین<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h4>
<p>وظیفه به شرح زیر است:
برای یک مقدار داده شده <span class="arithmatex">$x$</span>، باید به سرعت کوچکترین اندیس <span class="arithmatex">$i$</span> را پیدا کنیم به طوری که مجموع <span class="arithmatex">$i$</span> عنصر اول آرایه <span class="arithmatex">$a[]$</span> بزرگتر یا مساوی <span class="arithmatex">$x$</span> باشد (با فرض اینکه آرایه <span class="arithmatex">$a[]$</span> فقط شامل مقادیر غیرمنفی است).</p>
<p>این وظیفه را می‌توان با استفاده از جستجوی دودویی و محاسبه مجموع پیشوندها با درخت بازه حل کرد.
اما این کار به یک راه حل <span class="arithmatex">$O(\log^2 n)$</span> منجر می‌شود.</p>
<p>در عوض می‌توانیم از همان ایده بخش قبلی استفاده کنیم و موقعیت را با پایین رفتن در درخت پیدا کنیم:
با حرکت هر بار به چپ یا راست، بسته به مجموع فرزند چپ.
بنابراین پاسخ را در زمان <span class="arithmatex">$O(\log n)$</span> پیدا می‌کنیم.</p>
<h4 id="_13">جستجو برای اولین عنصر بزرگتر از یک مقدار معین<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h4>
<p>وظیفه به شرح زیر است:
برای یک مقدار داده شده <span class="arithmatex">$x$</span> و یک بازه <span class="arithmatex">$a[l \dots r]$</span>، کوچکترین <span class="arithmatex">$i$</span> را در بازه <span class="arithmatex">$a[l \dots r]$</span> پیدا کنید، به طوری که <span class="arithmatex">$a[i]$</span> بزرگتر از <span class="arithmatex">$x$</span> باشد.</p>
<p>این وظیفه را می‌توان با استفاده از جستجوی دودویی روی پرس‌وجوهای بیشینه پیشوند با درخت بازه حل کرد.
اما این کار به یک راه حل <span class="arithmatex">$O(\log^2 n)$</span> منجر می‌شود.</p>
<p>در عوض، می‌توانیم از همان ایده بخش‌های قبلی استفاده کنیم و موقعیت را با پایین رفتن در درخت پیدا کنیم:
با حرکت هر بار به چپ یا راست، بسته به مقدار بیشینه فرزند چپ.
بنابراین پاسخ را در زمان <span class="arithmatex">$O(\log n)$</span> پیدا می‌کنیم.</p>
<div class="cpp highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">get_first</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">tr</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">tl</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">tr</span><span class="o">-</span><span class="n">tl</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_first</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">left</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">get_first</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="_14">یافتن زیربازه‌ها با بیشترین مجموع<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h4>
<p>در اینجا باز هم برای هر پرس‌وجو یک بازه <span class="arithmatex">$a[l \dots r]$</span> دریافت می‌کنیم، این بار باید یک زیربازه <span class="arithmatex">$a[l^\prime \dots r^\prime]$</span> پیدا کنیم به طوری که <span class="arithmatex">$l \le l^\prime$</span> و <span class="arithmatex">$r^\prime \le r$</span> و مجموع عناصر این بازه بیشینه باشد.
همانند قبل، می‌خواهیم بتوانیم عناصر جداگانه آرایه را نیز تغییر دهیم.
عناصر آرایه می‌توانند منفی باشند و زیربازه بهینه می‌تواند خالی باشد (مثلاً اگر همه عناصر منفی باشند).</p>
<p>این مسئله یک استفاده غیربدیهی از درخت بازه است.
این بار چهار مقدار برای هر رأس ذخیره خواهیم کرد:
مجموع بازه، بیشترین مجموع پیشوندی، بیشترین مجموع پسوندی، و مجموع زیربازه بیشینه در آن.
به عبارت دیگر، برای هر بازه از درخت بازه، پاسخ از قبل محاسبه شده است و همچنین پاسخ‌ها برای بازه‌هایی که با مرزهای چپ و راست بازه تماس دارند.</p>
<p>چگونه درختی با چنین داده‌هایی بسازیم؟
باز هم آن را به صورت بازگشتی محاسبه می‌کنیم:
ابتدا هر چهار مقدار را برای فرزندان چپ و راست محاسبه می‌کنیم، و سپس آنها را ترکیب می‌کنیم تا چهار مقدار برای رأس فعلی به دست آید.
توجه داشته باشید که پاسخ برای رأس فعلی یکی از موارد زیر است:</p>
<ul>
<li>پاسخ فرزند چپ، که به این معنی است که زیربازه بهینه کاملاً در بازه فرزند چپ قرار دارد.</li>
<li>پاسخ فرزند راست، که به این معنی است که زیربازه بهینه کاملاً در بازه فرزند راست قرار دارد.</li>
<li>مجموع بیشترین مجموع پسوندی فرزند چپ و بیشترین مجموع پیشوندی فرزند راست، که به این معنی است که زیربازه بهینه با هر دو فرزند تلاقی دارد.</li>
</ul>
<p>بنابراین پاسخ برای رأس فعلی، بیشینه این سه مقدار است.
محاسبه بیشترین مجموع پیشوندی / پسوندی حتی ساده‌تر است.
در اینجا پیاده‌سازی تابع <span class="arithmatex">$\text{combine}$</span> آمده است، که فقط داده‌ها را از فرزند چپ و راست دریافت می‌کند و داده‌های رأس فعلی را برمی‌گرداند.</p>
<div class="cpp highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">data</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="p">,</span><span class="w"> </span><span class="n">pref</span><span class="p">,</span><span class="w"> </span><span class="n">suff</span><span class="p">,</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">data</span><span class="w"> </span><span class="nf">combine</span><span class="p">(</span><span class="n">data</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="w">    </span><span class="n">res</span><span class="p">.</span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">sum</span><span class="p">;</span>
<span class="w">    </span><span class="n">res</span><span class="p">.</span><span class="n">pref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">pref</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">pref</span><span class="p">);</span>
<span class="w">    </span><span class="n">res</span><span class="p">.</span><span class="n">suff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">suff</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">sum</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">suff</span><span class="p">);</span>
<span class="w">    </span><span class="n">res</span><span class="p">.</span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">ans</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">ans</span><span class="p">),</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">suff</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">pref</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>با استفاده از تابع <span class="arithmatex">$\text{combine}$</span>، ساختن درخت بازه آسان است.
می‌توانیم آن را دقیقاً به همان روشی که در پیاده‌سازی‌های قبلی انجام دادیم، پیاده‌سازی کنیم.
برای مقداردهی اولیه به رأس‌های برگ، علاوه بر این، تابع کمکی <span class="arithmatex">$\text{make_data}$</span> را ایجاد می‌کنیم که یک شیء <span class="arithmatex">$\text{data}$</span> حاوی اطلاعات یک مقدار واحد را برمی‌گرداند.</p>
<div class="cpp highlight"><pre><span></span><code><span class="n">data</span><span class="w"> </span><span class="nf">make_data</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="w">    </span><span class="n">res</span><span class="p">.</span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="w">    </span><span class="n">res</span><span class="p">.</span><span class="n">pref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res</span><span class="p">.</span><span class="n">suff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res</span><span class="p">.</span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_data</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">tl</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">);</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">combine</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_data</span><span class="p">(</span><span class="n">new_val</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tm</span><span class="p">)</span>
<span class="w">            </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">combine</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>فقط باقی می‌ماند که چگونه به یک پرس‌وجو پاسخ دهیم.
برای پاسخ به آن، همانند قبل در درخت پایین می‌رویم، پرس‌وجو را به چندین زیربازه که با بازه‌های درخت بازه منطبق هستند، می‌شکنیم و پاسخ‌ها را در آنها به یک پاسخ واحد برای پرس‌وجو ترکیب می‌کنیم.
پس باید واضح باشد که کار دقیقاً مانند درخت بازه ساده است، اما به جای جمع / کمینه‌سازی / بیشینه‌سازی مقادیر، از تابع <span class="arithmatex">$\text{combine}$</span> استفاده می‌کنیم.</p>
<div class="cpp highlight"><pre><span></span><code><span class="n">data</span><span class="w"> </span><span class="nf">query</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">make_data</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">combine</span><span class="p">(</span><span class="n">query</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">)),</span><span class="w"> </span>
<span class="w">                   </span><span class="n">query</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_15"><a name="saving-the-entire-subarrays-in-each-vertex"></a>ذخیره کل زیرآرایه‌ها در هر رأس<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h3>
<p>این یک زیربخش جداگانه است که از بقیه متمایز است، زیرا در هر رأس از درخت بازه ما اطلاعات مربوط به بازه را به صورت فشرده ذخیره نمی‌کنیم (مجموع، کمینه، بیشینه، ...)، بلکه تمام عناصر بازه را ذخیره می‌کنیم.
بنابراین ریشه درخت بازه تمام عناصر آرایه را ذخیره خواهد کرد، رأس فرزند چپ نیمه اول آرایه را، رأس راست نیمه دوم را، و به همین ترتیب.</p>
<p>در ساده‌ترین کاربرد این تکنیک، ما عناصر را به ترتیب مرتب شده ذخیره می‌کنیم.
در نسخه‌های پیچیده‌تر، عناصر در لیست‌ها ذخیره نمی‌شوند، بلکه در ساختارهای داده پیشرفته‌تر (مجموعه‌ها، نقشه‌ها، ...) ذخیره می‌شوند.
اما همه این روش‌ها عامل مشترکی دارند، که هر رأس به حافظه خطی (یعنی متناسب با طول بازه مربوطه) نیاز دارد.</p>
<p>اولین سوال طبیعی هنگام در نظر گرفتن این درختان بازه، در مورد مصرف حافظه است.
به طور شهودی این ممکن است به نظر حافظه <span class="arithmatex">$O(n^2)$</span> برسد، اما معلوم می‌شود که کل درخت فقط به حافظه <span class="arithmatex">$O(n \log n)$</span> نیاز خواهد داشت.
چرا اینطور است؟
خیلی ساده، زیرا هر عنصر از آرایه در <span class="arithmatex">$O(\log n)$</span> بازه قرار می‌گیرد (به یاد داشته باشید ارتفاع درخت <span class="arithmatex">$O(\log n)$</span> است).</p>
<p>بنابراین با وجود اسراف ظاهری چنین درخت بازه‌ای، آن تنها کمی بیشتر از درخت بازه معمول حافظه مصرف می‌کند.</p>
<p>چندین کاربرد معمول این ساختار داده در زیر شرح داده شده است.
شایان ذکر است شباهت این درختان بازه با ساختارهای داده دو بعدی (در واقع این یک ساختار داده دو بعدی است، اما با قابلیت‌های نسبتاً محدود).</p>
<h4 id="_16">یافتن کوچکترین عدد بزرگتر یا مساوی با یک عدد مشخص. بدون پرس‌وجوی تغییر.<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h4>
<p>می‌خواهیم به پرس‌وجوهایی از فرم زیر پاسخ دهیم:
برای سه عدد داده شده <span class="arithmatex">$(l, r, x)$</span> باید کمترین عدد در بازه <span class="arithmatex">$a[l \dots r]$</span> را که بزرگتر یا مساوی <span class="arithmatex">$x$</span> است، پیدا کنیم.</p>
<p>یک درخت بازه می‌سازیم.
در هر رأس، یک لیست مرتب شده از تمام اعدادی که در بازه مربوطه ظاهر می‌شوند را ذخیره می‌کنیم، همانطور که در بالا توضیح داده شد.
چگونه چنین درخت بازه‌ای را تا حد امکان به طور موثر بسازیم؟
مثل همیشه به این مسئله به صورت بازگشتی نزدیک می‌شویم: فرض کنید لیست‌های فرزندان چپ و راست از قبل ساخته شده‌اند و ما می‌خواهیم لیست را برای رأس فعلی بسازیم.
از این دیدگاه، عملیات اکنون بدیهی است و می‌تواند در زمان خطی انجام شود:
ما فقط باید دو لیست مرتب شده را در یک لیست ترکیب کنیم، که این کار را می‌توان با پیمایش آنها با استفاده از دو اشاره‌گر انجام داد.
STL سی‌پلاس‌پلاس از قبل یک پیاده‌سازی از این الگوریتم دارد.</p>
<p>به دلیل این ساختار درخت بازه و شباهت‌ها به الگوریتم مرتب‌سازی ادغامی، این ساختار داده اغلب "درخت مرتب‌سازی ادغامی" نیز نامیده می‌شود.</p>
<div class="cpp highlight"><pre><span></span><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">MAXN</span><span class="p">];</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">tl</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">);</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">);</span>
<span class="w">        </span><span class="n">merge</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">].</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">].</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">end</span><span class="p">(),</span>
<span class="w">              </span><span class="n">back_inserter</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>ما از قبل می‌دانیم که درخت بازه ساخته شده به این روش به حافظه <span class="arithmatex">$O(n \log n)$</span> نیاز خواهد داشت.
و به لطف این پیاده‌سازی، ساخت آن نیز <span class="arithmatex">$O(n \log n)$</span> زمان می‌برد، زیرا هر لیست در زمان خطی نسبت به اندازه‌اش ساخته می‌شود.</p>
<p>اکنون پاسخ به پرس‌وجو را در نظر بگیرید.
ما مانند درخت بازه معمولی در درخت پایین می‌رویم و بازه خود <span class="arithmatex">$a[l \dots r]$</span> را به چندین زیربازه می‌شکنیم (حداکثر به <span class="arithmatex">$O(\log n)$</span> قطعه).
واضح است که پاسخ کل، کمینه هر یک از زیرپرس‌وجوها است.
بنابراین اکنون فقط باید بفهمیم که چگونه به یک پرس‌وجو در یکی از این زیربازه‌ها که با برخی از رأس‌های درخت مطابقت دارد، پاسخ دهیم.</p>
<p>ما در برخی از رأس‌های درخت بازه هستیم و می‌خواهیم پاسخ به پرس‌وجو را محاسبه کنیم، یعنی کمترین عدد بزرگتر یا مساوی با عدد داده شده <span class="arithmatex">$x$</span> را پیدا کنیم.
از آنجایی که رأس شامل لیست عناصر به ترتیب مرتب شده است، می‌توانیم به سادگی یک جستجوی دودویی در این لیست انجام دهیم و اولین عدد بزرگتر یا مساوی <span class="arithmatex">$x$</span> را برگردانیم.</p>
<p>بنابراین پاسخ به پرس‌وجو در یک بازه از درخت <span class="arithmatex">$O(\log n)$</span> زمان می‌برد، و کل پرس‌وجو در <span class="arithmatex">$O(\log^2 n)$</span> پردازش می‌شود.</p>
<div class="cpp highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">query</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">INF</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lower_bound</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">end</span><span class="p">())</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">pos</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">INF</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">query</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">),</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w"> </span>
<span class="w">               </span><span class="n">query</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p>ثابت <span class="arithmatex">$\text{INF}$</span> برابر با یک عدد بزرگ است که از تمام اعداد آرایه بزرگتر است.
استفاده از آن به این معنی است که هیچ عدد بزرگتر یا مساوی <span class="arithmatex">$x$</span> در بازه وجود ندارد.
معنای آن "هیچ پاسخی در بازه داده شده وجود ندارد" است.</p>
<h4 id="_17">یافتن کوچکترین عدد بزرگتر یا مساوی یک عدد مشخص. با پرس‌وجوهای تغییر.<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h4>
<p>این وظیفه شبیه به قبلی است.
رویکرد قبلی یک نقطه ضعف داشت، امکان تغییر آرایه بین پاسخ به پرس‌وجوها وجود نداشت.
اکنون می‌خواهیم دقیقاً همین کار را انجام دهیم: یک پرس‌وجوی تغییر، انتساب <span class="arithmatex">$a[i] = y$</span> را انجام خواهد داد.</p>
<p>راه حل شبیه به راه حل مسئله قبلی است، اما به جای لیست‌ها در هر رأس درخت بازه، یک لیست متعادل ذخیره خواهیم کرد که به شما امکان می‌دهد به سرعت اعداد را جستجو کنید، اعداد را حذف کنید و اعداد جدید را درج کنید.
از آنجایی که آرایه می‌تواند یک عدد را به صورت مکرر داشته باشد، انتخاب بهینه ساختار داده <span class="arithmatex">$\text{multiset}$</span> است.</p>
<p>ساخت چنین درخت بازه‌ای تقریباً به همان روشی که در مسئله قبلی انجام شد، انجام می‌شود، فقط اکنون باید <span class="arithmatex">$\text{multiset}$</span>ها را ترکیب کنیم و نه لیست‌های مرتب شده.
این منجر به زمان ساخت <span class="arithmatex">$O(n \log^2 n)$</span> می‌شود (به طور کلی ادغام دو درخت قرمز-سیاه را می‌توان در زمان خطی انجام داد، اما STL سی‌پلاس‌پلاس این پیچیدگی زمانی را تضمین نمی‌کند).</p>
<p>تابع <span class="arithmatex">$\text{query}$</span> نیز تقریباً معادل است، فقط اکنون باید تابع <span class="arithmatex">$\text{lower_bound}$</span> از <span class="arithmatex">$\text{multiset}$</span> فراخوانی شود (تابع <span class="arithmatex">$\text{std::lower_bound}$</span> فقط در زمان <span class="arithmatex">$O(\log n)$</span> کار می‌کند اگر با تکرارگرهای با دسترسی تصادفی استفاده شود).</p>
<p>در نهایت درخواست تغییر.
برای پردازش آن، باید در درخت پایین برویم و تمام <span class="arithmatex">$\text{multiset}$</span>های بازه‌های مربوطه که حاوی عنصر تحت تأثیر هستند را تغییر دهیم.
ما به سادگی مقدار قدیمی این عنصر را حذف می‌کنیم (اما فقط یک رخداد) و مقدار جدید را درج می‌کنیم.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">erase</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">pos</span><span class="p">]));</span>
<span class="w">    </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">new_val</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tm</span><span class="p">)</span>
<span class="w">            </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">a</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_val</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>پردازش این درخواست تغییر نیز <span class="arithmatex">$O(\log^2 n)$</span> زمان می‌برد.</p>
<h4 id="fractional-cascading">یافتن کوچکترین عدد بزرگتر یا مساوی یک عدد مشخص. شتاب‌دهی با "آبشار کسری" (fractional cascading).<a class="headerlink" href="#fractional-cascading" title="Permanent link">&para;</a></h4>
<p>ما همان صورت مسئله را داریم، می‌خواهیم کمترین عدد بزرگتر یا مساوی <span class="arithmatex">$x$</span> را در یک بازه پیدا کنیم، اما این بار در زمان <span class="arithmatex">$O(\log n)$</span>.
ما پیچیدگی زمانی را با استفاده از تکنیک "آبشار کسری" بهبود خواهیم داد.</p>
<p>آبشار کسری یک تکنیک ساده است که به شما امکان می‌دهد زمان اجرای چندین جستجوی دودویی که به طور همزمان انجام می‌شوند را بهبود بخشید.
رویکرد قبلی ما برای پرس‌وجوی جستجو این بود که وظیفه را به چندین زیروظیفه تقسیم می‌کردیم که هر کدام با یک جستجوی دودویی حل می‌شدند.
آبشار کسری به شما امکان می‌دهد همه این جستجوهای دودویی را با یک جستجوی واحد جایگزین کنید.</p>
<p>ساده‌ترین و واضح‌ترین مثال از آبشار کسری مسئله زیر است:
<span class="arithmatex">$k$</span> لیست مرتب شده از اعداد وجود دارد و ما باید در هر لیست اولین عدد بزرگتر یا مساوی با عدد داده شده را پیدا کنیم.</p>
<p>به جای انجام یک جستجوی دودویی برای هر لیست، می‌توانیم همه لیست‌ها را در یک لیست بزرگ مرتب شده ادغام کنیم.
علاوه بر این برای هر عنصر <span class="arithmatex">$y$</span> یک لیست از نتایج جستجوی <span class="arithmatex">$y$</span> در هر یک از <span class="arithmatex">$k$</span> لیست را ذخیره می‌کنیم.
بنابراین اگر بخواهیم کوچکترین عدد بزرگتر یا مساوی <span class="arithmatex">$x$</span> را پیدا کنیم، فقط باید یک جستجوی دودویی واحد انجام دهیم و از لیست اندیس‌ها می‌توانیم کوچکترین عدد را در هر لیست تعیین کنیم.
این رویکرد اما به <span class="arithmatex">$O(n \cdot k)$</span> حافظه نیاز دارد (<span class="arithmatex">$n$</span> طول لیست‌های ترکیبی است)، که می‌تواند کاملاً ناکارآمد باشد.</p>
<p>آبشار کسری این پیچیدگی حافظه را با ایجاد <span class="arithmatex">$k$</span> لیست جدید از <span class="arithmatex">$k$</span> لیست ورودی به حافظه <span class="arithmatex">$O(n)$</span> کاهش می‌دهد، که در آن هر لیست شامل لیست مربوطه و علاوه بر آن هر عنصر دوم از لیست جدید بعدی است.
با استفاده از این ساختار، فقط لازم است دو اندیس ذخیره شود، اندیس عنصر در لیست اصلی و اندیس عنصر در لیست جدید بعدی.
بنابراین این رویکرد فقط از حافظه <span class="arithmatex">$O(n)$</span> استفاده می‌کند و هنوز هم می‌تواند به پرس‌وجوها با استفاده از یک جستجوی دودویی واحد پاسخ دهد.</p>
<p>اما برای کاربرد ما، به قدرت کامل آبشار کسری نیازی نداریم.
در درخت بازه ما، یک رأس شامل لیست مرتب شده از تمام عناصری است که در زیردرخت‌های چپ یا راست وجود دارند (مانند درخت مرتب‌سازی ادغامی).
علاوه بر این لیست مرتب شده، برای هر عنصر دو موقعیت ذخیره می‌کنیم.
برای یک عنصر <span class="arithmatex">$y$</span>، کوچکترین اندیس <span class="arithmatex">$i$</span> را ذخیره می‌کنیم، به طوری که عنصر <span class="arithmatex">$i$</span>-ام در لیست مرتب شده فرزند چپ بزرگتر یا مساوی <span class="arithmatex">$y$</span> باشد.
و کوچکترین اندیس <span class="arithmatex">$j$</span> را ذخیره می‌کنیم، به طوری که عنصر <span class="arithmatex">$j$</span>-ام در لیست مرتب شده فرزند راست بزرگتر یا مساوی <span class="arithmatex">$y$</span> باشد.
این مقادیر را می‌توان به صورت موازی با مرحله ادغام هنگام ساخت درخت محاسبه کرد.</p>
<p>این چگونه پرس‌وجوها را سرعت می‌بخشد؟</p>
<p>به یاد بیاورید، در راه حل عادی ما در هر گره یک جستجوی دودویی انجام می‌دادیم.
اما با این تغییر، می‌توانیم از همه آنها به جز یکی اجتناب کنیم.</p>
<p>برای پاسخ به یک پرس‌وجو، ما به سادگی یک جستجوی دودویی در گره ریشه انجام می‌دهیم.
این به ما کوچکترین عنصر <span class="arithmatex">$y \ge x$</span> را در کل آرایه می‌دهد، اما همچنین دو موقعیت به ما می‌دهد.
اندیس کوچکترین عنصر بزرگتر یا مساوی <span class="arithmatex">$x$</span> در زیردرخت چپ، و اندیس کوچکترین عنصر <span class="arithmatex">$y$</span> در زیردرخت راست. توجه داشته باشید که <span class="arithmatex">$\ge y$</span> همان <span class="arithmatex">$\ge x$</span> است، زیرا آرایه ما هیچ عنصری بین <span class="arithmatex">$x$</span> و <span class="arithmatex">$y$</span> ندارد.
در راه حل عادی درخت مرتب‌سازی ادغامی، ما این اندیس‌ها را از طریق جستجوی دودویی محاسبه می‌کردیم، اما با کمک مقادیر از پیش محاسبه شده می‌توانیم آنها را در <span class="arithmatex">$O(1)$</span> پیدا کنیم.
و می‌توانیم این کار را تکرار کنیم تا زمانی که همه گره‌هایی که بازه پرس‌وجوی ما را پوشش می‌دهند، بازدید کنیم.</p>
<p>به طور خلاصه، مانند معمول در طول یک پرس‌وجو <span class="arithmatex">$O(\log n)$</span> گره را لمس می‌کنیم. در گره ریشه یک جستجوی دودویی انجام می‌دهیم، و در همه گره‌های دیگر فقط کار ثابت انجام می‌دهیم.
این بدان معناست که پیچیدگی پاسخ به یک پرس‌وجو <span class="arithmatex">$O(\log n)$</span> است.</p>
<p>اما توجه داشته باشید که این سه برابر بیشتر از یک درخت مرتب‌سازی ادغامی عادی حافظه مصرف می‌کند، که خود از قبل حافظه زیادی (<span class="arithmatex">$O(n \log n)$</span>) مصرف می‌کند.</p>
<p>اعمال این تکنیک به مسئله‌ای که به هیچ پرس‌وجوی تغییری نیاز ندارد، ساده است.
دو موقعیت فقط اعداد صحیح هستند و به راحتی با شمارش هنگام ادغام دو دنباله مرتب شده قابل محاسبه هستند.</p>
<p>هنوز هم امکان اجازه دادن به پرس‌وجوهای تغییر وجود دارد، اما این کل کد را پیچیده می‌کند.
به جای اعداد صحیح، باید آرایه مرتب شده را به صورت <code>multiset</code> ذخیره کنید، و به جای اندیس‌ها باید تکرارگرها را ذخیره کنید.
و باید با دقت بسیار کار کنید تا در طول یک پرس‌وجوی تغییر، تکرارگرهای صحیح را افزایش یا کاهش دهید.</p>
<h4 id="_18">سایر تغییرات ممکن<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h4>
<p>این تکنیک یک کلاس کاملاً جدید از کاربردهای ممکن را نشان می‌دهد.
به جای ذخیره یک <span class="arithmatex">$\text{vector}$</span> یا یک <span class="arithmatex">$\text{multiset}$</span> در هر رأس، می‌توان از ساختارهای داده دیگری استفاده کرد:
درختان بازه دیگر (تا حدودی در <a href="segment_tree.html#generalization-to-higher-dimensions">تعمیم به ابعاد بالاتر</a> بحث شده است)، درختان فن‌ویک، درختان کارتزین و غیره.</p>
<h3 id="lazy-propagation">به‌روزرسانی‌های بازه‌ای (انتشار با تأخیر یا Lazy Propagation)<a class="headerlink" href="#lazy-propagation" title="Permanent link">&para;</a></h3>
<p>تمام مسائل در بخش‌های بالا پرس‌وجوهای تغییری را مورد بحث قرار دادند که هر بار فقط یک عنصر از آرایه را تحت تأثیر قرار می‌دادند.
اما درخت بازه امکان اعمال پرس‌وجوهای تغییر را به یک بازه کامل از عناصر متوالی می‌دهد و پرس‌وجو را در همان زمان <span class="arithmatex">$O(\log n)$</span> انجام می‌دهد.</p>
<h4 id="_19">افزودن در بازه‌ها<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h4>
<p>با در نظر گرفتن مسائل به ساده‌ترین شکل شروع می‌کنیم: پرس‌وجوی تغییر باید عدد <span class="arithmatex">$x$</span> را به تمام اعداد در بازه <span class="arithmatex">$a[l \dots r]$</span> اضافه کند.
پرس‌وجوی دومی که قرار است به آن پاسخ دهیم، به سادگی مقدار <span class="arithmatex">$a[i]$</span> را می‌پرسد.</p>
<p>برای کارآمد کردن پرس‌وجوی افزودن، در هر رأس در درخت بازه ذخیره می‌کنیم که چقدر باید به تمام اعداد در بازه مربوطه اضافه کنیم.
برای مثال، اگر پرس‌وجوی "افزودن 3 به کل آرایه <span class="arithmatex">$a[0 \dots n-1]$</span>" بیاید، آنگاه عدد 3 را در ریشه درخت قرار می‌دهیم.
به طور کلی باید این عدد را در چندین بازه قرار دهیم که یک افراز از بازه پرس‌وجو را تشکیل می‌دهند.
بنابراین نیازی به تغییر تمام <span class="arithmatex">$O(n)$</span> مقادیر نداریم، بلکه فقط <span class="arithmatex">$O(\log n)$</span> مقدار.</p>
<p>اگر اکنون پرس‌وجویی بیاید که مقدار فعلی یک ورودی خاص آرایه را بپرسد، کافی است در درخت پایین برویم و تمام مقادیر یافت شده در طول مسیر را جمع کنیم.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">tl</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">);</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">add</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">add</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">),</span><span class="w"> </span><span class="n">add</span><span class="p">);</span>
<span class="w">        </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tm</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="_20">انتساب در بازه‌ها<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h4>
<p>حال فرض کنید که پرس‌وجوی تغییر می‌خواهد هر عنصر از یک بازه مشخص <span class="arithmatex">$a[l \dots r]$</span> را به مقداری <span class="arithmatex">$p$</span> اختصاص دهد.
به عنوان پرس‌وجوی دوم، باز هم خواندن مقدار آرایه <span class="arithmatex">$a[i]$</span> را در نظر خواهیم گرفت.</p>
<p>برای انجام این پرس‌وجوی تغییر در یک بازه کامل، باید در هر رأس از درخت بازه ذخیره کنیم که آیا بازه مربوطه به طور کامل با یک مقدار یکسان پوشانده شده است یا نه.
این به ما امکان می‌دهد یک به‌روزرسانی "تنبل" (lazy) انجام دهیم:
به جای تغییر تمام بازه‌هایی در درخت که بازه پرس‌وجو را پوشش می‌دهند، ما فقط برخی را تغییر می‌دهیم و بقیه را بدون تغییر باقی می‌گذاریم.
یک رأس علامت‌گذاری شده به این معنی است که هر عنصر از بازه مربوطه به آن مقدار اختصاص داده شده است، و در واقع کل زیردرخت نیز باید فقط شامل این مقدار باشد.
به نوعی ما تنبلی می‌کنیم و نوشتن مقدار جدید را به همه آن رأس‌ها به تعویق می‌اندازیم.
می‌توانیم این کار خسته‌کننده را بعداً، اگر لازم شد، انجام دهیم.</p>
<p>بنابراین پس از اجرای پرس‌وجوی تغییر، برخی از بخش‌های درخت نامربوط می‌شوند - برخی از تغییرات در آن انجام نشده باقی می‌مانند.</p>
<p>برای مثال اگر یک پرس‌وجوی تغییر "اختصاص یک عدد به کل آرایه <span class="arithmatex">$a[0 \dots n-1]$</span>" اجرا شود، در درخت بازه فقط یک تغییر ایجاد می‌شود - عدد در ریشه درخت قرار می‌گیرد و این رأس علامت‌گذاری می‌شود.
بازه های باقیمانده بدون تغییر باقی می‌مانند، اگرچه در واقع عدد باید در کل درخت قرار گیرد.</p>
<p>حال فرض کنید که پرس‌وجوی تغییر دوم می‌گوید که نیمه اول آرایه <span class="arithmatex">$a[0 \dots n/2]$</span> باید با عدد دیگری اختصاص داده شود.
برای پردازش این پرس‌وجو باید هر عنصر در کل فرزند چپ رأس ریشه را با آن عدد اختصاص دهیم.
اما قبل از اینکه این کار را انجام دهیم، باید ابتدا رأس ریشه را مرتب کنیم.
نکته ظریف در اینجا این است که نیمه راست آرایه هنوز باید به مقدار پرس‌وجوی اول اختصاص داده شود، و در حال حاضر هیچ اطلاعاتی برای نیمه راست ذخیره نشده است.</p>
<p>راه حل این است که اطلاعات ریشه را به فرزندانش منتقل (push) کنیم، یعنی اگر ریشه درخت با هر عددی اختصاص داده شده بود، آنگاه رأس‌های فرزند چپ و راست را با این عدد اختصاص می‌دهیم و علامت ریشه را حذف می‌کنیم.
پس از آن، می‌توانیم فرزند چپ را با مقدار جدید اختصاص دهیم، بدون اینکه اطلاعات ضروری را از دست بدهیم.</p>
<p>به طور خلاصه:
برای هر پرس‌وجو (یک پرس‌وجوی تغییر یا خواندن) در حین پایین رفتن در درخت، باید همیشه اطلاعات را از رأس فعلی به هر دو فرزندش منتقل کنیم.
می‌توانیم این را به این صورت درک کنیم که وقتی در درخت پایین می‌رویم، تغییرات تأخیری را اعمال می‌کنیم، اما دقیقاً به اندازه‌ای که لازم است (تا پیچیدگی <span class="arithmatex">$O(\log n)$</span> را کاهش ندهیم).</p>
<p>برای پیاده‌سازی، باید یک تابع <span class="arithmatex">$\text{push}$</span> بسازیم، که رأس فعلی را دریافت می‌کند و اطلاعات رأس خود را به هر دو فرزندش منتقل می‌کند.
ما این تابع را در ابتدای توابع پرس‌وجو فراخوانی خواهیم کرد (اما آن را از برگ‌ها فراخوانی نخواهیم کرد، زیرا نیازی به انتقال اطلاعات از آنها به پایین‌تر نیست).</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">        </span><span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">tr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_val</span><span class="p">;</span>
<span class="w">        </span><span class="n">marked</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">),</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tm</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>توجه: تابع <span class="arithmatex">$\text{get}$</span> را می‌توان به روش دیگری نیز پیاده‌سازی کرد:
به‌روزرسانی‌های تأخیری را انجام ندهید، بلکه اگر <span class="arithmatex">$marked[v]$</span> درست بود، بلافاصله مقدار <span class="arithmatex">$t[v]$</span> را برگردانید.</p>
<h4 id="_21">افزودن در بازه‌ها، پرس‌وجوی بیشینه<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h4>
<p>اکنون پرس‌وجوی تغییر، افزودن یک عدد به تمام عناصر در یک بازه است، و پرس‌وجوی خواندن، یافتن بیشینه در یک بازه است.</p>
<p>بنابراین برای هر رأس از درخت بازه، باید بیشینه زیربازه مربوطه را ذخیره کنیم.
بخش جالب این است که چگونه این مقادیر را در حین یک درخواست تغییر دوباره محاسبه کنیم.</p>
<p>برای این منظور، یک مقدار اضافی برای هر رأس نگه می‌داریم.
در این مقدار، مقادیر افزودنی را که به رأس‌های فرزند منتقل نکرده‌ایم، ذخیره می‌کنیم.
قبل از پیمایش به یک رأس فرزند، تابع <span class="arithmatex">$\text{push}$</span> را فراخوانی کرده و مقدار را به هر دو فرزند منتقل می‌کنیم.
باید این کار را هم در تابع <span class="arithmatex">$\text{update}$</span> و هم در تابع <span class="arithmatex">$\text{query}$</span> انجام دهیم.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">tl</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">);</span>
<span class="w">        </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">lazy</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="n">lazy</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">lazy</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">lazy</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="n">lazy</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">lazy</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="n">lazy</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">addend</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">tr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">addend</span><span class="p">;</span>
<span class="w">        </span><span class="n">lazy</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">addend</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">),</span><span class="w"> </span><span class="n">addend</span><span class="p">);</span>
<span class="w">        </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">addend</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">query</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">INF</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">tr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">query</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">)),</span><span class="w"> </span>
<span class="w">               </span><span class="n">query</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_22"><a name="generalization-to-higher-dimensions"></a>تعمیم به ابعاد بالاتر<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h3>
<p>یک درخت بازه را می‌توان به طور کاملاً طبیعی به ابعاد بالاتر تعمیم داد.
اگر در حالت یک‌بعدی اندیس‌های آرایه را به بازه‌هایی تقسیم می‌کنیم، در حالت دوبعدی یک درخت بازه معمولی نسبت به اندیس‌های اول می‌سازیم، و برای هر بازه یک درخت بازه معمولی نسبت به اندیس‌های دوم می‌سازیم.</p>
<h4 id="_23">درخت بازه ساده دوبعدی<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h4>
<p>یک ماتریس <span class="arithmatex">$a[0 \dots n-1, 0 \dots m-1]$</span> داده شده است، و ما باید مجموع (یا کمینه/بیشینه) را در یک زیرماتریس <span class="arithmatex">$a[x_1 \dots x_2, y_1 \dots y_2]$</span> پیدا کنیم، و همچنین تغییرات عناصر جداگانه ماتریس را انجام دهیم (یعنی پرس‌وجوهایی از نوع <span class="arithmatex">$a[x][y] = p$</span>).</p>
<p>بنابراین یک درخت بازه دوبعدی می‌سازیم: ابتدا درخت بازه با استفاده از مختصات اول (<span class="arithmatex">$x$</span>)، سپس دوم (<span class="arithmatex">$y$</span>).</p>
<p>برای قابل فهم‌تر کردن فرآیند ساخت، می‌توانید برای مدتی فراموش کنید که ماتریس دوبعدی است و فقط مختصات اول را در نظر بگیرید.
ما یک درخت بازه یک‌بعدی معمولی با استفاده از فقط مختصات اول خواهیم ساخت.
اما به جای ذخیره یک عدد در یک بازه، ما یک درخت بازه کامل را ذخیره می‌کنیم:
یعنی در این لحظه به یاد می‌آوریم که یک مختصات دوم نیز داریم؛ اما چون در این لحظه مختصات اول به یک بازه <span class="arithmatex">$[l \dots r]$</span> ثابت شده است، ما در واقع با چنین نواری <span class="arithmatex">$a[l \dots r, 0 \dots m-1]$</span> کار می‌کنیم و برای آن یک درخت بازه می‌سازیم.</p>
<p>در اینجا پیاده‌سازی ساخت یک درخت بازه دوبعدی آمده است.
این در واقع دو بلوک جداگانه را نشان می‌دهد:
ساخت یک درخت بازه در امتداد مختصات <span class="arithmatex">$x$</span> (<span class="arithmatex">$\text{build}_x$</span>)، و مختصات <span class="arithmatex">$y$</span> (<span class="arithmatex">$\text{build}_y$</span>).
برای گره‌های برگ در <span class="arithmatex">$\text{build}_y$</span> باید دو حالت را جدا کنیم:
وقتی بازه فعلی مختصات اول <span class="arithmatex">$[tlx \dots trx]$</span> طول ۱ دارد، و وقتی طول آن بیشتر از یک است. در حالت اول، ما فقط مقدار مربوطه را از ماتریس می‌گیریم، و در حالت دوم می‌توانیم مقادیر دو درخت بازه از پسر چپ و راست در مختصات <span class="arithmatex">$x$</span> را ترکیب کنیم.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">build_y</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vy</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ly</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span>
<span class="w">            </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">lx</span><span class="p">][</span><span class="n">ly</span><span class="p">];</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="p">][</span><span class="n">vy</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">vy</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">my</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ly</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">build_y</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="n">my</span><span class="p">);</span>
<span class="w">        </span><span class="n">build_y</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">my</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ry</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">build_x</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lx</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">mx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">build_x</span><span class="p">(</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">mx</span><span class="p">);</span>
<span class="w">        </span><span class="n">build_x</span><span class="p">(</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">mx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">build_y</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="mi">-1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>چنین درخت بازه‌ای هنوز از مقدار حافظه خطی استفاده می‌کند، اما با یک ثابت بزرگتر: <span class="arithmatex">$16 n m$</span>.
واضح است که رویه توصیف شده <span class="arithmatex">$\text{build}_x$</span> نیز در زمان خطی کار می‌کند.</p>
<p>اکنون به پردازش پرس‌وجوها می‌پردازیم. ما به پرس‌وجوی دوبعدی با همان اصل پاسخ خواهیم داد:
ابتدا پرس‌وجو را بر روی مختصات اول می‌شکنیم، و سپس برای هر رأس رسیده، درخت بازه مربوطه از مختصات دوم را فراخوانی می‌کنیم.</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">sum_y</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vy</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tly</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">try_</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ly</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ly</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tly</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">try_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tmy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tly</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">try_</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum_y</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tly</span><span class="p">,</span><span class="w"> </span><span class="n">tmy</span><span class="p">,</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">ry</span><span class="p">,</span><span class="w"> </span><span class="n">tmy</span><span class="p">))</span>
<span class="w">         </span><span class="o">+</span><span class="w"> </span><span class="n">sum_y</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tmy</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">try_</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="n">tmy</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">ry</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">sum_x</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tlx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">trx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lx</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tlx</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">trx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">sum_y</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="n">ry</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tmx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tlx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">trx</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum_x</span><span class="p">(</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">tlx</span><span class="p">,</span><span class="w"> </span><span class="n">tmx</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="n">tmx</span><span class="p">),</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span>
<span class="w">         </span><span class="o">+</span><span class="w"> </span><span class="n">sum_x</span><span class="p">(</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tmx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">trx</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">tmx</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="n">ry</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>این تابع در زمان <span class="arithmatex">$O(\log n \log m)$</span> کار می‌کند، زیرا ابتدا در درخت در مختصات اول پایین می‌رود، و برای هر رأس پیمایش شده در درخت، یک پرس‌وجو در درخت بازه مربوطه در امتداد مختصات دوم انجام می‌دهد.</p>
<p>در نهایت پرس‌وجوی تغییر را در نظر می‌گیریم.
ما می‌خواهیم یاد بگیریم چگونه درخت بازه را مطابق با تغییر در مقدار یک عنصر <span class="arithmatex">$a[x][y] = p$</span> تغییر دهیم.
واضح است که تغییرات فقط در آن رأس‌های درخت بازه اول که مختصات <span class="arithmatex">$x$</span> را پوشش می‌دهند رخ می‌دهد (و چنین رأس‌هایی <span class="arithmatex">$O(\log n)$</span> خواهند بود)، و برای درختان بازه مربوط به آنها تغییرات فقط در آن رأس‌هایی رخ می‌دهد که مختصات <span class="arithmatex">$y$</span> را پوشش می‌دهند (و چنین رأس‌هایی <span class="arithmatex">$O(\log m)$</span> خواهند بود).
بنابراین پیاده‌سازی تفاوت چندانی با حالت یک‌بعدی نخواهد داشت، فقط اکنون ابتدا در مختصات اول پایین می‌رویم، و سپس در مختصات دوم.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">update_y</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">vy</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ry</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ly</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span>
<span class="w">            </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_val</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="p">][</span><span class="n">vy</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">vy</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">my</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ly</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ry</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">my</span><span class="p">)</span>
<span class="w">            </span><span class="n">update_y</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">ly</span><span class="p">,</span><span class="w"> </span><span class="n">my</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">update_y</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">my</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ry</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t</span><span class="p">[</span><span class="n">vx</span><span class="p">][</span><span class="n">vy</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">update_x</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lx</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">mx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">lx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">mx</span><span class="p">)</span>
<span class="w">            </span><span class="n">update_x</span><span class="p">(</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">mx</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">update_x</span><span class="p">(</span><span class="n">vx</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">mx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">update_y</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="_24">فشرده‌سازی درخت بازه دوبعدی<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h4>
<p>فرض کنید مسئله به این صورت است: <span class="arithmatex">$n$</span> نقطه در صفحه با مختصاتشان <span class="arithmatex">$(x_i, y_i)$</span> داده شده‌اند و پرس‌وجوهایی از نوع "تعداد نقاطی که در مستطیل <span class="arithmatex">$((x_1, y_1), (x_2, y_2))$</span> قرار دارند را بشمار" وجود دارد.
واضح است که در چنین مسئله‌ای ساخت یک درخت بازه دوبعدی با <span class="arithmatex">$O(n^2)$</span> عنصر به طور غیر منطقی پرهزینه است.
بیشتر این حافظه هدر خواهد رفت، زیرا هر نقطه تنها می‌تواند در <span class="arithmatex">$O(\log n)$</span> بازه از درخت در امتداد مختصات اول قرار گیرد، و بنابراین اندازه "مفید" کل تمام بازه‌های درخت در مختصات دوم <span class="arithmatex">$O(n \log n)$</span> است.</p>
<p>بنابراین به صورت زیر عمل می‌کنیم:
در هر رأس از درخت بازه نسبت به مختصات اول، یک درخت بازه ساخته شده فقط با آن مختصات دومی که در بازه فعلی مختصات اول وجود دارند، ذخیره می‌کنیم.
به عبارت دیگر، هنگام ساخت یک درخت بازه در داخل یک رأس با اندیس <span class="arithmatex">$vx$</span> و مرزهای <span class="arithmatex">$tlx$</span> و <span class="arithmatex">$trx$</span>، ما فقط آن نقاطی را در نظر می‌گیریم که در این بازه <span class="arithmatex">$x \in [tlx, trx]$</span> قرار می‌گیرند، و یک درخت بازه فقط با استفاده از آنها می‌سازیم.</p>
<p>بنابراین ما به این دست می‌یابیم که هر درخت بازه در مختصات دوم دقیقاً به اندازه‌ای حافظه اشغال خواهد کرد که باید.
در نتیجه، کل حافظه به <span class="arithmatex">$O(n \log n)$</span> کاهش می‌یابد.
ما هنوز می‌توانیم به پرس‌وجوها در زمان <span class="arithmatex">$O(\log^2 n)$</span> پاسخ دهیم، فقط باید یک جستجوی دودویی در مختصات دوم انجام دهیم، اما این پیچیدگی را بدتر نخواهد کرد.</p>
<p>اما پرس‌وجوهای تغییر با این ساختار غیرممکن خواهند بود:
در واقع اگر یک نقطه جدید ظاهر شود، ما باید یک عنصر جدید را در وسط یک درخت بازه در امتداد مختصات دوم اضافه کنیم، که به طور موثر قابل انجام نیست.</p>
<p>در پایان اشاره می‌کنیم که درخت بازه دوبعدی که به روش توصیف شده فشرده شده است، عملاً معادل تغییر درخت بازه یک‌بعدی می‌شود (بخش <a href="segment_tree.html#saving-the-entire-subarrays-in-each-vertex">ذخیره کل زیرآرایه‌ها در هر رأس</a> را ببینید).
به طور خاص، درخت بازه دوبعدی فقط یک مورد خاص از ذخیره یک زیرآرایه در هر رأس از درخت است.
از این رو، اگر مجبور به رها کردن یک درخت بازه دوبعدی به دلیل عدم امکان اجرای یک پرس‌وجو شدید، منطقی است که سعی کنید درخت بازه تودرتو را با یک ساختار داده قدرتمندتر، به عنوان مثال یک درخت کارتزین، جایگزین کنید.</p>
<h3 id="_25">حفظ تاریخچه مقادیر (درخت بازه پایدار)<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h3>
<p>یک ساختمان داده پایدار، ساختمانی داده‌ای است که حالت قبلی خود را برای هر تغییر به یاد می‌آورد.
این امکان دسترسی به هر نسخه‌ای از این ساختمان داده که مورد علاقه ماست و اجرای پرس‌وجو بر روی آن را فراهم می‌کند.</p>
<p>درخت بازه ساختمانی داده‌ای است که می‌تواند به طور بهینه (هم از نظر زمان و هم از نظر مصرف حافظه) به یک ساختمان داده پایدار تبدیل شود.
ما می‌خواهیم از کپی کردن کل درخت قبل از هر تغییر اجتناب کنیم، و نمی‌خواهیم رفتار زمانی <span class="arithmatex">$O(\log n)$</span> را برای پاسخ به پرس‌وجوهای بازه‌ای از دست بدهیم.</p>
<p>در واقع، هر درخواست تغییر در درخت بازه منجر به تغییر در داده‌های تنها <span class="arithmatex">$O(\log n)$</span> رأس در طول مسیر از ریشه می‌شود.
بنابراین اگر درخت بازه را با استفاده از اشاره‌گرها ذخیره کنیم (یعنی یک رأس اشاره‌گرهایی به رأس‌های فرزند چپ و راست را ذخیره کند)، آنگاه هنگام انجام پرس‌وجوی تغییر، به سادگی باید رأس‌های جدیدی ایجاد کنیم به جای تغییر رأس‌های موجود.
رأس‌هایی که تحت تأثیر پرس‌وجوی تغییر قرار نمی‌گیرند، هنوز هم می‌توانند با اشاره کردن اشاره‌گرها به رأس‌های قدیمی استفاده شوند.
بنابراین برای یک پرس‌وجوی تغییر <span class="arithmatex">$O(\log n)$</span> رأس جدید ایجاد می‌شود، از جمله یک رأس ریشه جدید برای درخت بازه، و کل نسخه قبلی درخت با ریشه قدیمی بدون تغییر باقی می‌ماند.</p>
<p>بیایید یک مثال پیاده‌سازی برای ساده‌ترین درخت بازه ارائه دهیم: وقتی فقط یک پرس‌وجوی مجموع و پرس‌وجوهای تغییر عناصر تکی وجود دارد.</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Vertex</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="o">*</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">r</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>

<span class="w">    </span><span class="n">Vertex</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">l</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="n">Vertex</span><span class="p">(</span><span class="n">Vertex</span><span class="w"> </span><span class="o">*</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">Vertex</span><span class="w"> </span><span class="o">*</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">l</span><span class="p">(</span><span class="n">l</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">(</span><span class="n">r</span><span class="p">),</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">l</span><span class="o">-&gt;</span><span class="n">sum</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">sum</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">Vertex</span><span class="o">*</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">tl</span><span class="p">]);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">),</span><span class="w"> </span><span class="n">build</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">get_sum</span><span class="p">(</span><span class="n">Vertex</span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">tr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">v</span><span class="o">-&gt;</span><span class="n">sum</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">get_sum</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">))</span>
<span class="w">         </span><span class="o">+</span><span class="w"> </span><span class="n">get_sum</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Vertex</span><span class="o">*</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="n">Vertex</span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">new_val</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tm</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">),</span><span class="w"> </span><span class="n">v</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">new_val</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p>برای هر تغییر در درخت بازه، یک رأس ریشه جدید دریافت خواهیم کرد.
برای پرش سریع بین دو نسخه مختلف از درخت بازه، باید این ریشه‌ها را در یک آرایه ذخیره کنیم.
برای استفاده از یک نسخه خاص از درخت بازه، به سادگی پرس‌وجو را با استفاده از رأس ریشه مناسب فراخوانی می‌کنیم.</p>
<p>با رویکرد توصیف شده در بالا، تقریباً هر درخت بازه‌ای را می‌توان به یک ساختمان داده پایدار تبدیل کرد.</p>
<h4 id="k-">یافتن <span class="arithmatex">$k$</span>-امین کوچکترین عدد در یک بازه<a class="headerlink" href="#k-" title="Permanent link">&para;</a></h4>
<p>این بار باید به پرس‌وجوهایی از نوع "k-امین کوچکترین عنصر در بازه <span class="arithmatex">$a[l \dots r]$</span> چیست؟" پاسخ دهیم.
این پرس‌وجو را می‌توان با استفاده از جستجوی دودویی و یک درخت مرتب‌سازی ادغامی پاسخ داد، اما پیچیدگی زمانی برای یک پرس‌وجوی واحد <span class="arithmatex">$O(\log^3 n)$</span> خواهد بود.
ما همین کار را با استفاده از یک درخت بازه پایدار در <span class="arithmatex">$O(\log n)$</span> انجام خواهیم داد.</p>
<p>ابتدا یک راه حل برای یک مسئله ساده‌تر را بحث خواهیم کرد:
ما فقط آرایه‌هایی را در نظر خواهیم گرفت که عناصر آنها در محدوده <span class="arithmatex">$0 \le a[i] \lt n$</span> قرار دارند.
و ما فقط می‌خواهیم <span class="arithmatex">$k$</span>-امین کوچکترین عنصر را در یک پیشوند از آرایه <span class="arithmatex">$a$</span> پیدا کنیم.
گسترش ایده‌های توسعه یافته بعداً برای آرایه‌های بدون محدودیت و پرس‌وجوهای بازه‌ای بدون محدودیت بسیار آسان خواهد بود.
توجه داشته باشید که ما از اندیس‌گذاری مبتنی بر ۱ برای <span class="arithmatex">$a$</span> استفاده خواهیم کرد.</p>
<p>ما از یک درخت بازه استفاده خواهیم کرد که تمام اعداد ظاهر شده را می‌شمارد، یعنی در درخت بازه ما هیستوگرام آرایه را ذخیره خواهیم کرد.
بنابراین رأس‌های برگ ذخیره می‌کنند که مقادیر <span class="arithmatex">$0$</span>، <span class="arithmatex">$1$</span>، <span class="arithmatex">$\dots$</span>، <span class="arithmatex">$n-1$</span> چند بار در آرایه ظاهر می‌شوند، و رأس‌های دیگر ذخیره می‌کنند که چند عدد در یک بازه مشخص در آرایه وجود دارند.
به عبارت دیگر ما یک درخت بازه معمولی با پرس‌وجوهای مجموع روی هیستوگرام آرایه ایجاد می‌کنیم.
اما به جای ایجاد همه <span class="arithmatex">$n$</span> درخت بازه برای هر پیشوند ممکن، ما یک درخت پایدار ایجاد خواهیم کرد که همان اطلاعات را در بر خواهد داشت.
ما با یک درخت بازه خالی (تمام شمارش‌ها <span class="arithmatex">$0$</span> خواهند بود) که توسط <span class="arithmatex">$root_0$</span> اشاره می‌شود، شروع خواهیم کرد و عناصر <span class="arithmatex">$a[1]$</span>، <span class="arithmatex">$a[2]$</span>، <span class="arithmatex">$\dots$</span>، <span class="arithmatex">$a[n]$</span> را یکی پس از دیگری اضافه خواهیم کرد.
برای هر تغییر، یک رأس ریشه جدید دریافت خواهیم کرد، بیایید <span class="arithmatex">$root_i$</span> را ریشه درخت بازه پس از درج <span class="arithmatex">$i$</span> عنصر اول آرایه <span class="arithmatex">$a$</span> بنامیم.
درخت بازه با ریشه <span class="arithmatex">$root_i$</span> حاوی هیستوگرام پیشوند <span class="arithmatex">$a[1 \dots i]$</span> خواهد بود.
با استفاده از این درخت بازه می‌توانیم در زمان <span class="arithmatex">$O(\log n)$</span> موقعیت <span class="arithmatex">$k$</span>-امین عنصر را با استفاده از همان تکنیک مورد بحث در <a href="segment_tree.html#counting-zero-search-kth">شمارش تعداد صفرها، جستجو برای <span class="arithmatex">$k$</span>-امین صفر</a> پیدا کنیم.</p>
<p>اکنون به نسخه بدون محدودیت مسئله می‌پردازیم.</p>
<p>ابتدا برای محدودیت روی پرس‌وجوها:
به جای انجام این پرس‌وجوها فقط روی یک پیشوند از <span class="arithmatex">$a$</span>، می‌خواهیم از هر بازه دلخواه <span class="arithmatex">$a[l \dots r]$</span> استفاده کنیم.
در اینجا ما به یک درخت بازه نیاز داریم که هیستوگرام عناصر در بازه <span class="arithmatex">$a[l \dots r]$</span> را نشان دهد.
به راحتی می‌توان دید که چنین درخت بازه‌ای فقط تفاوت بین درخت بازه با ریشه <span class="arithmatex">$root_{r}$</span> و درخت بازه با ریشه <span class="arithmatex">$root_{l-1}$</span> است، یعنی هر رأس در درخت بازه <span class="arithmatex">$[l \dots r]$</span> را می‌توان با رأس درخت <span class="arithmatex">$root_{r}$</span> منهای رأس درخت <span class="arithmatex">$root_{l-1}$</span> محاسبه کرد.</p>
<p>در پیاده‌سازی تابع <span class="arithmatex">$\text{find_kth}$</span> این را می‌توان با پاس دادن دو اشاره‌گر رأس و محاسبه شمارش/مجموع بازه فعلی به عنوان تفاوت دو شمارش/مجموع رأس‌ها مدیریت کرد.</p>
<p>در اینجا توابع اصلاح شده <span class="arithmatex">$\text{build}$</span>، <span class="arithmatex">$\text{update}$</span> و <span class="arithmatex">$\text{find_kth}$</span> آمده است.</p>
<div class="cpp highlight"><pre><span></span><code><span class="n">Vertex</span><span class="o">*</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">build</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">),</span><span class="w"> </span><span class="n">build</span><span class="p">(</span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">Vertex</span><span class="o">*</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="n">Vertex</span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pos</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">sum</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">tm</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">),</span><span class="w"> </span><span class="n">v</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">find_kth</span><span class="p">(</span><span class="n">Vertex</span><span class="o">*</span><span class="w"> </span><span class="n">vl</span><span class="p">,</span><span class="w"> </span><span class="n">Vertex</span><span class="w"> </span><span class="o">*</span><span class="n">vr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">tl</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">left_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vr</span><span class="o">-&gt;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">sum</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">vl</span><span class="o">-&gt;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">sum</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">left_count</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">k</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">find_kth</span><span class="p">(</span><span class="n">vl</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">vr</span><span class="o">-&gt;</span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">find_kth</span><span class="p">(</span><span class="n">vl</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">vr</span><span class="o">-&gt;</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">tm</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="o">-</span><span class="n">left_count</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>همانطور که قبلاً نوشته شد، باید ریشه درخت بازه اولیه و همچنین تمام ریشه‌ها پس از هر به‌روزرسانی را ذخیره کنیم.
در اینجا کد ساخت یک درخت بازه پایدار روی یک وکتور <code>a</code> با عناصر در بازه <code>[0, MAX_VALUE]</code> آمده است.</p>
<div class="cpp highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">tl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAX_VALUE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">roots</span><span class="p">;</span>
<span class="n">roots</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">build</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">));</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">roots</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">update</span><span class="p">(</span><span class="n">roots</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
<span class="p">}</span>

<span class="c1">// یافتن پنجمین کوچکترین عدد از زیرآرایه [a[2], a[3], ..., a[19]]</span>
<span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_kth</span><span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">roots</span><span class="p">[</span><span class="mi">20</span><span class="p">],</span><span class="w"> </span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">tr</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
</code></pre></div>
<p>اکنون به محدودیت‌ها روی عناصر آرایه:
ما در واقع می‌توانیم هر آرایه‌ای را با فشرده‌سازی اندیس به چنین آرایه‌ای تبدیل کنیم.
کوچکترین عنصر در آرایه مقدار 0، دومین کوچکترین مقدار 1 و به همین ترتیب تخصیص داده می‌شود.
تولید جداول جستجو (مثلاً با استفاده از <span class="arithmatex">$\text{map}$</span>) که یک مقدار را به اندیس آن و بالعکس در زمان <span class="arithmatex">$O(\log n)$</span> تبدیل می‌کنند، آسان است.</p>
<h3 id="_26">درخت بازه پویا<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h3>
<p>(به این دلیل اینطور نامیده می‌شود که شکل آن پویاست و گره‌ها معمولاً به صورت پویا تخصیص داده می‌شوند.
همچنین به عنوان <em>درخت بازه ضمنی</em> یا <em>درخت بازه پراکنده</em> نیز شناخته می‌شود.)</p>
<p>قبلاً، مواردی را در نظر گرفتیم که توانایی ساخت درخت بازه اصلی را داشتیم. اما چه باید کرد اگر اندازه اصلی با یک عنصر پیش‌فرض پر شده باشد، اما اندازه‌اش اجازه ندهد که از قبل به طور کامل آن را بسازیم؟</p>
<p>ما می‌توانیم این مشکل را با ایجاد یک درخت بازه به صورت تنبل (افزایشی) حل کنیم. در ابتدا، ما فقط ریشه را ایجاد خواهیم کرد و گره‌های دیگر را فقط زمانی که به آنها نیاز داریم ایجاد خواهیم کرد.
در این حالت، از پیاده‌سازی بر روی اشاره‌گرها استفاده خواهیم کرد (قبل از رفتن به فرزندان گره، بررسی کنید که آیا ایجاد شده‌اند و اگر نه، آنها را ایجاد کنید).
هر پرس‌وجو هنوز فقط پیچیدگی <span class="arithmatex">$O(\log n)$</span> را دارد، که برای اکثر موارد استفاده به اندازه کافی کوچک است (مثلاً <span class="arithmatex">$\log_2 10^9 \approx 30$</span>).</p>
<p>در این پیاده‌سازی ما دو پرس‌وجو داریم، اضافه کردن یک مقدار به یک موقعیت (در ابتدا تمام مقادیر <span class="arithmatex">$0$</span> هستند)، و محاسبه مجموع تمام مقادیر در یک بازه.
<code>Vertex(0, n)</code> رأس ریشه درخت ضمنی خواهد بود.</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Vertex</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="o">*</span><span class="n">left_child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">right_child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="w">    </span><span class="n">Vertex</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lb</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rb</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lb</span><span class="p">;</span>
<span class="w">        </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rb</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">extend</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">left_child</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">            </span><span class="n">left_child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">);</span>
<span class="w">            </span><span class="n">right_child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vertex</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">extend</span><span class="p">();</span>
<span class="w">        </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">left_child</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">left_child</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
<span class="w">                </span><span class="n">left_child</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">                </span><span class="n">right_child</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">get_sum</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">lq</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">rq</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lq</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">rq</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">lq</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">rq</span><span class="p">))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">extend</span><span class="p">();</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">left_child</span><span class="o">-&gt;</span><span class="n">get_sum</span><span class="p">(</span><span class="n">lq</span><span class="p">,</span><span class="w"> </span><span class="n">rq</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">right_child</span><span class="o">-&gt;</span><span class="n">get_sum</span><span class="p">(</span><span class="n">lq</span><span class="p">,</span><span class="w"> </span><span class="n">rq</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>بدیهی است که این ایده را می‌توان به روش‌های مختلفی گسترش داد. به عنوان مثال، با افزودن پشتیبانی از به‌روزرسانی‌های بازه‌ای از طریق انتشار با تأخیر.</p>
<h2 id="_27">مسائل تمرینی<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="http://www.spoj.com/problems/KQUERY/">SPOJ - KQUERY</a> [درخت بازه‌ی پایدار / درخت مرتب‌سازی ادغامی]</li>
<li><a href="https://codeforces.com/problemset/problem/339/D">Codeforces - Xenia and Bit Operations</a></li>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2397">UVA 11402 - Ahoy, Pirates!</a></li>
<li><a href="http://www.spoj.com/problems/GSS3/">SPOJ - GSS3</a></li>
<li><a href="https://codeforces.com/problemset/problem/1234/D">Codeforces - Distinct Characters Queries</a></li>
<li><a href="https://codeforces.com/contest/356/problem/A">Codeforces - Knight Tournament</a> [برای مبتدیان]</li>
<li><a href="https://codeforces.com/contest/474/problem/F">Codeforces - Ant colony</a></li>
<li><a href="https://codeforces.com/contest/515/problem/E">Codeforces - Drazil and Park</a></li>
<li><a href="https://codeforces.com/problemset/problem/52/C">Codeforces - Circular RMQ</a></li>
<li><a href="https://codeforces.com/contest/121/problem/E">Codeforces - Lucky Array</a></li>
<li><a href="https://codeforces.com/contest/438/problem/D">Codeforces - The Child and Sequence</a></li>
<li><a href="https://codeforces.com/contest/446/problem/C">Codeforces - DZY Loves Fibonacci Numbers</a> [انتشار با تأخیر]</li>
<li><a href="https://codeforces.com/problemset/problem/610/E">Codeforces - Alphabet Permutations</a></li>
<li><a href="https://codeforces.com/problemset/problem/895/E">Codeforces - Eyes Closed</a></li>
<li><a href="https://codeforces.com/problemset/problem/580/E">Codeforces - Kefa and Watch</a></li>
<li><a href="https://codeforces.com/problemset/problem/558/E">Codeforces - A Simple Task</a></li>
<li><a href="https://codeforces.com/problemset/problem/920/F">Codeforces - SUM and REPLACE</a></li>
<li><a href="https://codeforces.com/problemset/problem/242/E">Codeforces - XOR on Segment</a> [انتشار با تأخیر]</li>
<li><a href="https://codeforces.com/problemset/problem/1114/F">Codeforces - Please, another Queries on Array?</a> [انتشار با تأخیر]</li>
<li><a href="https://oj.uz/problem/view/COCI17_deda">COCI - Deda</a> [آخرین عنصر کوچکتر یا مساوی x / جستجوی دودویی]</li>
<li><a href="https://codeforces.com/problemset/problem/869/E">Codeforces - The Untended Antiquity</a> [دوبعدی]</li>
<li><a href="https://cses.fi/problemset/task/1143">CSES - Hotel Queries</a></li>
<li><a href="https://cses.fi/problemset/task/1736">CSES - Polynomial Queries</a></li>
<li><a href="https://cses.fi/problemset/task/1735">CSES - Range Updates and Sums</a></li>
</ul>

<ul class="metadata page-metadata" data-bi-name="page info" lang="en-us" dir="ltr">
  <span class="contributors-text">Contributors:</span>
  <ul class="contributors" data-bi-name="contributors"><li><a href="https://github.com/jakobkogler" title="jakobkogler" data-bi-name="contributorprofile" target="_blank">jakobkogler</a> (47.739999999999995%)</li><li><a href="https://github.com/2077DevWave" title="2077DevWave" data-bi-name="contributorprofile" target="_blank">2077DevWave</a> (39.01%)</li><li><a href="https://github.com/dasfex" title="dasfex" data-bi-name="contributorprofile" target="_blank">dasfex</a> (4.03%)</li><li><a href="https://github.com/arjan-bal" title="arjan-bal" data-bi-name="contributorprofile" target="_blank">arjan-bal</a> (3.46%)</li><li><a href="https://github.com/masterchef2209" title="masterchef2209" data-bi-name="contributorprofile" target="_blank">masterchef2209</a> (1.23%)</li><li><a href="https://github.com/akoutian" title="akoutian" data-bi-name="contributorprofile" target="_blank">akoutian</a> (0.91%)</li><li><a href="https://github.com/L1nkus" title="L1nkus" data-bi-name="contributorprofile" target="_blank">L1nkus</a> (0.8999999999999999%)</li><li><a href="https://github.com/tpoppo" title="tpoppo" data-bi-name="contributorprofile" target="_blank">tpoppo</a> (0.74%)</li><li><a href="https://github.com/GaurangTandon" title="GaurangTandon" data-bi-name="contributorprofile" target="_blank">GaurangTandon</a> (0.58%)</li><li><a href="https://github.com/mhayter" title="mhayter" data-bi-name="contributorprofile" target="_blank">mhayter</a> (0.41%)</li><li><a href="https://github.com/adamant-pwn" title="adamant-pwn" data-bi-name="contributorprofile" target="_blank">adamant-pwn</a> (0.41%)</li><li><a href="https://github.com/zyrch" title="zyrch" data-bi-name="contributorprofile" target="_blank">zyrch</a> (0.16%)</li><li><a href="https://github.com/wikku" title="wikku" data-bi-name="contributorprofile" target="_blank">wikku</a> (0.08%)</li><li><a href="https://github.com/DevChoganwala" title="DevChoganwala" data-bi-name="contributorprofile" target="_blank">DevChoganwala</a> (0.08%)</li><li><a href="https://github.com/jxu" title="jxu" data-bi-name="contributorprofile" target="_blank">jxu</a> (0.08%)</li><li><a href="https://github.com/Aryamn" title="Aryamn" data-bi-name="contributorprofile" target="_blank">Aryamn</a> (0.08%)</li><li><a href="https://github.com/prashantkn94" title="prashantkn94" data-bi-name="contributorprofile" target="_blank">prashantkn94</a> (0.08%)</li></ul>
</ul>
                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      

<footer class="md-footer">
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Text is available under the <a href="https://github.com/cp-algorithms/cp-algorithms/blob/main/LICENSE">Creative Commons Attribution Share Alike 4.0 International</a> License<br/>Copyright &copy; 2014 - 2025 by <a href="https://github.com/cp-algorithms/cp-algorithms/graphs/contributors">cp-algorithms contributors</a>
          </div>
        
        
          Made with
          <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
            Material for MkDocs
          </a>
        
        
      </div>
      <div class="md-social">
  
</div>
    </div>
  </div>
</footer>

    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": ["toc.integrate", "search.suggest", "content.code.copy"], "search": "../assets/javascripts/workers/search.d50fe291.min.js", "tags": null, "translations": {"clipboard.copied": "\u06a9\u067e\u06cc \u0634\u062f", "clipboard.copy": "\u06a9\u067e\u06cc \u06a9\u0631\u062f\u0646", "search.result.more.one": "1 \u0645\u0648\u0631\u062f \u062f\u06cc\u06af\u0631 \u062f\u0631 \u0627\u06cc\u0646 \u0635\u0641\u062d\u0647", "search.result.more.other": "# \u0645\u0648\u0631\u062f \u062f\u06cc\u06af\u0631 \u062f\u0631 \u0627\u06cc\u0646 \u0635\u0641\u062d\u0647", "search.result.none": "\u0633\u0646\u062f\u06cc \u06cc\u0627\u0641\u062a \u0646\u0634\u062f", "search.result.one": "1 \u0633\u0646\u062f \u06cc\u0627\u0641\u062a \u0634\u062f", "search.result.other": "# \u0633\u0646\u062f \u06cc\u0627\u0641\u062a \u0634\u062f", "search.result.placeholder": "\u0628\u0631\u0627\u06cc \u0634\u0631\u0648\u0639 \u062c\u0633\u062a\u062c\u0648 \u062a\u0627\u06cc\u067e \u06a9\u0646\u06cc\u062f", "search.result.term.missing": "\u0645\u0648\u062c\u0648\u062f \u0646\u06cc\u0633\u062a", "select.version": "\u0627\u0646\u062a\u062e\u0627\u0628 \u0648\u06cc\u0631\u0627\u06cc\u0634"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.56ea9cef.min.js"></script>
      
        <script src="../javascript/config.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="../assets/javascripts/toggle-sidebar.js" async></script>
      
    
  </body>
</html>